<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es" dir="ltr" lang="es"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>
    tutorial_de_ensamblador    [La decadence]
  </title>

  <meta name="generator" content="DokuWiki Release 2009-12-25c &quot;Lemming&quot;">
<meta name="robots" content="index,follow">
<meta name="date" content="2012-11-04T10:32:22+0100">
<meta name="keywords" content="tutorial_de_ensamblador">
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.ladecadence.net/lib/exe/opensearch.php" title="La decadence">
<link rel="start" href="http://wiki.ladecadence.net/">
<link rel="contents" href="http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador&amp;do=index" title="Índice">
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="http://wiki.ladecadence.net/feed.php">
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="http://wiki.ladecadence.net/feed.php?mode=list&amp;ns=">
<link rel="alternate" type="text/html" title="Plain HTML" href="http://wiki.ladecadence.net/doku.php?do=export_xhtml&amp;id=tutorial_de_ensamblador">
<link rel="alternate" type="text/plain" title="Wiki Markup" href="http://wiki.ladecadence.net/doku.php?do=export_raw&amp;id=tutorial_de_ensamblador">
<link rel="canonical" href="http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador">
<link rel="stylesheet" media="all" type="text/css" href="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/css_002.css">
<link rel="stylesheet" media="screen" type="text/css" href="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/css_003.css">
<link rel="stylesheet" media="print" type="text/css" href="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/css.css">
<script type="text/javascript" charset="utf-8"><!--//--><![CDATA[//><!--
var NS='';var JSINFO = {"id":"tutorial_de_ensamblador","namespace":""};
//--><!]]></script>
<script type="text/javascript" charset="utf-8" src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/js.php"></script>

  <link rel="shortcut icon" href="http://wiki.ladecadence.net/lib/tpl/default/images/favicon.ico">

  </head>

<body>
<div class="dokuwiki">
  
  <div class="stylehead">

    <div class="header">
      <div class="pagename">
        [[<a href="http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador&amp;do=backlink" title="Enlaces anteriores">tutorial_de_ensamblador</a>]]
      </div>
      <div class="logo">
        <a href="http://wiki.ladecadence.net/doku.php" name="dokuwiki__top" id="dokuwiki__top" accesskey="h" title="[H]">La decadence</a>      </div>

      <div class="clearer"></div>
    </div>

    
    <div class="bar" id="bar__top">
      <div class="bar-left" id="bar__topleft">
        <form class="button btn_source" method="post" action="/doku.php"><div class="no"><input name="do" value="edit" type="hidden"><input name="rev" value="" type="hidden"><input name="id" value="tutorial_de_ensamblador" type="hidden"><input value="Ver fuente" class="button" accesskey="v" title="Ver fuente [V]" type="submit"></div></form>        <form class="button btn_revs" method="get" action="/doku.php"><div class="no"><input name="do" value="revisions" type="hidden"><input name="id" value="tutorial_de_ensamblador" type="hidden"><input value="Revisiones antiguas" class="button" accesskey="o" title="Revisiones antiguas [O]" type="submit"></div></form>      </div>

      <div class="bar-right" id="bar__topright">
        <form class="button btn_recent" method="get" action="/doku.php"><div class="no"><input name="do" value="recent" type="hidden"><input name="id" value="tutorial_de_ensamblador" type="hidden"><input value="Cambios recientes" class="button" accesskey="r" title="Cambios recientes [R]" type="submit"></div></form>        <form action="/doku.php" accept-charset="utf-8" class="search" id="dw__search"><div class="no"><input name="do" value="search" type="hidden"><input id="qsearch__in" accesskey="f" name="id" class="edit" title="[F]" type="text"><input value="Buscar" class="button" title="Buscar" type="submit"><div style="display: none;" id="qsearch__out" class="ajax_qsearch JSpopup"></div></div></form>&nbsp;
      </div>

      <div class="clearer"></div>
    </div>

        <div class="breadcrumbs">
      <span class="bchead">Traza:</span> <span class="bcsep">»</span> <span class="curid"><a href="http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador" class="breadcrumbs" title="tutorial_de_ensamblador">tutorial_de_ensamblador</a></span>          </div>
    
    
  </div>
  
  
  <div class="page">
    <!-- wikipage start -->
    <!-- TOC START -->
<div class="toc">
<div style="cursor: pointer;" class="tocheader toctoggle" id="toc__header"><span class="toc_close" style="cursor: pointer;" id="toc__toggle"><span>−</span></span>Tabla de Contenidos</div>
<div id="toc__inside">

<ul class="toc">
<li class="level1"><div class="li"><span class="li"><a href="#introduccion" class="toc">Introducción</a></span></div>
<ul class="toc">
<li class="clear">

<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#nintendo_gameboy_dmg" class="toc">Nintendo Gameboy (DMG)</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#gbz80" class="toc">GBz80</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#mapa_de_memoria" class="toc">Mapa de memoria</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#organizacion_de_una_rom_de_gameboy" class="toc">Organización de una ROM de GameBoy</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#sistema_de_video" class="toc">Sistema de vídeo</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#fondos" class="toc">Fondos</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#sprites" class="toc">Sprites</a></span></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><span class="li"><a href="#herramientas" class="toc">Herramientas</a></span></div>
<ul class="toc">
<li class="clear">

<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#ensamblador" class="toc">Ensamblador</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#editor" class="toc">Editor</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#emulador" class="toc">Emulador</a></span></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><span class="li"><a href="#hola_mundo" class="toc">Hola mundo</a></span></div>
<ul class="toc">
<li class="clear">

<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#codigo" class="toc">Código</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#explicacion" class="toc">Explicación</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#mejoras" class="toc">Mejoras</a></span></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><span class="li"><a href="#hola_sprites" class="toc">Hola sprites</a></span></div></li>
<li class="level1"><div class="li"><span class="li"><a href="#hola_joypad" class="toc">Hola JoyPad</a></span></div></li>
<li class="level1"><div class="li"><span class="li"><a href="#hola_ventana" class="toc">Hola Ventana</a></span></div></li>
<li class="level1"><div class="li"><span class="li"><a href="#hola_timer" class="toc">Hola Timer</a></span></div>
<ul class="toc">
<li class="clear">

<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#explicacion1" class="toc">Explicación</a></span></div></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><div class="li"><span class="li"><a href="#hola_bancos" class="toc">Hola Bancos</a></span></div></li>
<li class="level1"><div class="li"><span class="li"><a href="#hola_sonido" class="toc">Hola Sonido</a></span></div>
<ul class="toc">
<li class="clear">

<ul class="toc">
<li class="level3"><div class="li"><span class="li"><a href="#canal_1_-_tono_y_portamento" class="toc">Canal 1 - Tono y portamento</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#canal_2_-_tono" class="toc">Canal 2 - Tono</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#canal_3_-_onda_programable" class="toc">Canal 3 - Onda programable</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#canal_4_-_ruido" class="toc">Canal 4 - Ruido</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#registros_de_control_generales_del_sonido" class="toc">Registros de control generales del sonido</a></span></div></li>
<li class="level3"><div class="li"><span class="li"><a href="#ejemplo" class="toc">Ejemplo</a></span></div></li></ul>
</li></ul>
</li></ul>
</div>
</div>
<!-- TOC END -->



<h1><a name="introduccion" id="introduccion">Introducción</a></h1>
<div class="level1">
<pre class="code">    NINTENDO
   ______                     ____             
  / ____/___ _____ ___  ___  / __ )____  __  __
 / / __/ __ `/ __ `__ \/ _ \/ __  / __ \/ / / /
/ /_/ / /_/ / / / / / /  __/ /_/ / /_/ / /_/ / 
\____/\__,_/_/ /_/ /_/\___/_____/\____/\__, /  
                                      /____/   
			Programming Tutorial
			 By David Pello (ladecadence.net)

             _n_________________     
            |_|_______________|_|    
            |  ,-------------.  |    
            | |  .---------.  | |    
            | |  |         |  | |    
            | |  |         |  | |    
            | |  |         |  | |    
            | |  |         |  | |    
            | |  `---------'  | |   
            | `---------------' |  
            |   _ GAME BOY      |    
            | _| |_         ,-. |    
            ||_ O _|   ,-. "._,"|    
            |  |_|    "._,"   A | 
            |      _  _  B      |
            |     // //         |    
            |    // //  \\\\\\  |    
            |    `  `    \\\\\\ ,    
            |________...______,"     
</pre>

</div>

<h3><a name="nintendo_gameboy_dmg" id="nintendo_gameboy_dmg">Nintendo Gameboy (DMG)</a></h3>
<div class="level3">

<p>

To begin this tutorial development for gameboy, let's review a little the technical characteristics of our wonderful console:

</p>
<ul>
<li class="level1"><div class="li"> CPU: 8-bit Sharp LR35902 (Similar to the Z80) to 4.19 MHz <acronym title="Megahertz">MHz</acronym></div>
</li>
<li class="level1"><div class="li"> 8K RAM main</div>
</li>
<li class="level1"><div class="li"> 8K RAM Video </div>
</li>
<li class="level1"><div class="li"> 2.6 "LCD 160 × 144, 4 Tones</div>
</li>
<li class="level1"><div class="li"> Stereo, 4 channels</div>
</li>
<li class="level1"><div class="li"> Serial port (ext)</div>
</li>
<li class="level1"><div class="li"> 6V, 0.7A</div>
</li>
<li class="level1"><div class="li"> 90 mm x 148 x 32 mm</div>
</li>
</ul>

<p>

Well, in the heart of the GameBoy, have a CPU itself manufactured by Sharp for Nintendo, with the technical name of LR35902, we have a microprocessor somewhere between 8080 and Z80, because although it has the extra sets of registers Z80 or the index, if incorporates most of its extended instruction set, such as bit manipulation. It also incorporates additional circuitry for controlling the LCD, the joypad, serial and audio generation.
</p>

</div>

<h3><a name="gbz80" id="gbz80">GBz80</a></h3>
<div class="level3">

<p>

The CPU, let's call GBZ80 is a 8bit cpu with a bus of 16 bit addresses. That is, the data internally and in external memory are organized in bytes, and can address 2 ^ 16 = 64KB of external memory. 
</p>

</div>

<h4><a name="registros" id="registros">Registros</a></h4>
<div class="level4">

<p>
The GBZ80, has several internal registers, which can store data while operating with them and move them to or from the external memory to the CPU. These 8-bit registers are: a, b, c, d, e, h l.
</p>

</div>

<h4><a name="flags" id="flags">Flags</a></h4>
<div class="level4">

<p>

Then there is the special register 'f', that saves the state of the processor flags. The processor to perform certain operations, can enable or disable some of these flags, which will be very useful when it comes to programming. For example, a bit in this register is the Zero flag, which indicates if the result of the previous operation, has been zero or not. Not all operations modify the flags, but many of them if they do. To get to know all the operations you can perform GBZ80, you can take a look at the relevant section of the Pan Docs: <a href="http://gbdev.gg8.se/wiki/articles/CPU_Instruction_Set">http://gbdev.gg8.se/wiki/articles/CPU_Instruction_Set</a>
<p></p>
F registry flags are as follows: 
</p>

<p>
Los flags del registro f, son los siguientes:

</p>
<pre class="code">Bit Nombre (1)  (0)  Explicación
 7    zf    Z   NZ   Flag Zero 
 6    n     -   -    Flag addition / subtraction (BCD)
 5    h     -   -    Flag half carry (BCD)
 4    cy    C   NC   carry flag
 3-0  -     -   -    Not used (always zero)
</pre>

<p>
 The most commonly used flags are:
</p>

</div>

<h5><a name="flag_zero_z" id="flag_zero_z">Zero Flag (Z)</a></h5>
<div class="level5">

<p>
This bit is set to 1 if the operation result was zero (0). Widely used in conditional jumps.
</p>

</div>

<h5><a name="flag_de_acarreo_c_o_cy" id="flag_de_acarreo_c_o_cy">Carry flag (C, or Cy)</a></h5>
<div class="level5">

<p>

It is set to 1 when the result of a sum is greater than $ FF (8bit) or $ FFFF (16bit), or when the result of comparison or subtraction is less than zero. In addition it puts one on one instruction when rotation or displacement, the operation takes to be a 1. Used in conditional jumps or instructions as ADC, SBC, RL, RLA, etc.
</p>

</div>

<h4><a name="registros_de_16_bit" id="registros_de_16_bit">16-bit registers</a></h4>
<div class="level4">

<p>
Some of these registers can be combined to form 16-bit registers, very useful for managing memory addresses or if we need larger numbers. The 16-bit registers are: AF, BC, DE, and HL.

We also have two other special registers, the PC, and program counter, 16 bits, which stores the memory address of the next instruction to be executed, and the sp, or stack pointer, also 16 bits, which stores the pointer the battery. 
</p>

</div>

<h3><a name="mapa_de_memoria" id="mapa_de_memoria">Memory Maps</a></h3>
<div class="level3">

<p>

The main memory of the gameboy, mapped 16-bit space, allows us to directly address 64K (2 ^ 16 = 65536). In this address space, we have to address all memory blocks to which you need access gameboy, ie RAM, ROM cartridge, internal RAM cartridge games record games, video memory, etc. For designers it GameBoy memory mapped in different blocks necessary, as internal RAM and video memory, leaving two blocks to access 16K ROM games, and 8K block access the RAM of the games (savegames). As many games began to require more than 32K of ROM or RAM 8K saved, he began to use a technique called "Banking", in which the ROM of the game is divided into several blocks that may wean (graphics or sounds of each screen for example), to be mapping in the block memory access as needed. In the Game Boy, this is designed as follows; We have a fixed block of 16K (where the main logic programmed the game), and then, by certain instructions (depending on the chip mapping that we use in our cartridge), we can go exchanging 16K banks in the other block available. It sounds complicated, but we'll talk about later banking. All this is reflected in the following memory map with all the available blocks in the address space of the GameBoy.
</p>
<pre class="code"> 
  General map memory banks writing records
 -------------------------                 ----------------------------------

   Activation record 
   Interruptions
 ---------------------------------- $FFFF
   High Internal RAM
 ---------------------------------- $FF80
  Not usable
 ---------------------------------- $FF4C
  Ports E / S
 ---------------------------------- $FF00
  Not usable
 ---------------------------------- $FEA0
  Sprite attributes (OAM)
 ---------------------------------- $FE00
  Mirror of internal RAM 8KB 
 ---------------------------------- $E000
  8kB of internal RAM
 ---------------------------------- $C000       ------------------------------
  Interchangeable 8KB RAM bank / Selector MBC1 ROM / RAM / Selector MBC1 ROM/RAM
 ---------------------------------- $A000     /  -----------------------------
  8kB Video RAM                              /  /     Ram bank Selector
 ---------------------------------- $8000 --/  /  ----------------------------
  16kB interchangeable ROM bank  $6000 ----/  /    Selector bank ROM
 ---------------------------------- $4000 ------/  ---------------------------
  16KB ROM Bank # 0              $2000 --------/   RAM Bank Activation
 ---------------------------------- $0000 ------------------------------------

</pre>

<p>

 * <strong>NOTE</strong>: b = bit, B = byte
</p>

<p>
 * <strong>NOTE</strong>: Using RGBDS convention, the assembler will use in the tutorial, the numbers in hexadecimal notation, write with a "$" in front, in binary with a "%" and without decimal code.
</p>

</div>

<h3><a name="organizacion_de_una_rom_de_gameboy" id="organizacion_de_una_rom_de_gameboy">Organizing a GameBoy ROM</a></h3>
<div class="level3">

<p>

GameBoy ROMs have to keep some structure for the GameBoy accept them, especially in the subject header. Below I detail the parts of a ROM and its function:

</p>
<pre class="code"> OUTLINE OF AN IMAGE GameBoy ROM
------------------------------------

$0    -  $100:	Interrupt vectors.  Although it is also possible to use these 
			 directions to get your code
				
$100  -  $103:	Entry point to the implementation of the program, normally 
		 usually put a nop, followed by a jump to our own
		 starting point.
				
$104  - $14E:	Header cartridge.  Contains nintendo logo (104h-133h)
		 which it is compared with that in the right boot rom
		 the console, if not coiciden, execution stops.
		
		Then we have the following data:
		
		$134 - Cartridge Name - 15bytes
		
		$143 - Gameboy Color Support
			$80 = GBColor, $00 or other = B/N
					
		$144 - license code, 2 bytes (not important)
		
		$146 - supergameboy Support (GBS)
			00 = GameBoy, 03 = Super GameBoy
					
		$147 - cartridge type (only ROM, MBC1, MBC1 + RAM etc ..)
			 0 - SOLO ROM                12 - ROM+MBC3+RAM
			 1 - ROM+MBC1                13 - ROM+MBC3+RAM+BATT
			 2 - ROM+MBC1+RAM            19 - ROM+MBC5
			 3 - ROM+MBC1+RAM+BATT       1A - ROM+MBC5+RAM
			 5 - ROM+MBC                 1B - ROM+MBC5+RAM+BATT
			 6 - ROM+MBC2+BATT           1C - ROM+MBC5+RUMBLE
			 8 - ROM+RAM                 1D - ROM+MBC5+RUMBLE+SRAM
			 9 - ROM+RAM+BATT            1E - ROM+MBC5+RUMBLE+SRAM+BATT
			 B - ROM+MMM01               1F - GBCamara
			 C - ROM+MMM01+SRAM          FD - Bandai TAMA5
			 D - ROM+MMM01+SRAM+BATT     FE - Hudson HuC-3
		 	 F - ROM+MBC3+TIMER+BATT     FF - Hudson HuC-1
			10 - ROM+MBC3+TIMER+RAM+BATT
			11 - ROM+MBC3
			
		$148 - Size ROM 
			  0 - 256Kbit =  32KByte =   2 banks
		  	  1 - 512Kbit =  64KByte =   4 banks
		   	  2 -   1Mbit = 128KByte =   8 banks
		  	  3 -   2Mbit = 256KByte =  16 banks
		  	  4 -   4Mbit = 512KByte =  32 banks
		  	  5 -   8Mbit =   1MByte =  64 banks
		  	  6 -  16Mbit =   2MByte = 128 banks
			$52 -   9Mbit = 1.1MByte =  72 banks
			$53 -  10Mbit = 1.2MByte =  80 banks
			$54 -  12Mbit = 1.5MByte =  96 banks
			
		$149 - Size RAM
			0 - None
			1 -  16kBit =  2kB = 1 banks
			2 -  64kBit =  8kB = 1 banks
			3 - 256kBit = 32kB = 4 banks
			4 -   1MBit =128kB =16 banks
			
		$ 14A - Area Code 
			 0 - Japanese
			 1 - No Japanese
			
		$ 14B - old license code, 2 bytes 
			 $ 33 - find the code at $ 0144 / $ 0145
			 (SGB functions do not work if not $ 33)
		
		$ 14C - ROM version (normally $ 00)
		
		$ 14D - Test complement (important)
		
		$ 14E - Checksum (not important)

 $ 14F - $ 3FFF: Our code.  This is the bank 0 16K, and is fixed.

$ 4000 - $ 7FFF: Second 16K bank.  At the start of the gameboy this is
		 It corresponds to bank 1 (up to 32K of ROM), but could 
		 be exchanged for 16K top banks to total
		 ROM we have available using a mapper as MBC1.

</pre>

</div>

<h3><a name="sistema_de_video" id="sistema_de_video">Video System</a></h3>
<div class="level3">

<p>
The video system of the GameBoy, is not a system of direct access pixel by pixel, as in a PC, but a system of blocks or "tiles". It consists of a buffer of 256 × 256 pixels (32 × 32 tiles) from which you can display 160 × 144 at all times (actual screen size, 20 × 18 tiles). We have a couple of scrollx and scrolly, records that allow us to move the buffer to the viewable area. Furthermore the buffer is circular, when done scroll beyond one end of the buffer, we begin to display data on the opposite side.
</p>
<pre class="code">				  ^
				  |
				  v

		+------------------------------------+
		|(scrollx, scrolly)                  |
		|   +----------------+               |
		|   |                |               |
		|   |                |               |
		|   |                |               |
		|   |     20x18      |               |
		|   |  Visible area  |               |
		|   |                |               |
		|   |                |               |
	&lt;-&gt;	|   |                |               |	&lt;-&gt;
		|   +----------------+               |
		|                                    |
		|                32x32               |
		|            Background map          |
		|                                    |
		|                                    |
		|                                    |
		|                                    |
		|                                    |
		+------------------------------------+		
				  ^
				  |
				  v

</pre>

<p>
The registers that control the video system are very important because they allow us to control what we show on screen, and how. The most important to start with are:
</p>

</div>

<h4><a name="ff40_-_lcdc_-_control_del_lcd_r_w" id="ff40_-_lcdc_-_control_del_lcd_r_w">$ FF40 - LCDC - LCD Control (R / W)</a></h4>
<div class="level4">

<p>
This control register allows us to adjust the screen GameBoy, which we handle for any operation that involves showing something in it<p></p>
Each bit of this register has a special siginificado, which I'll detail:
</p>

<p>
Cada bit de este registro tiene un siginificado especial, que pasaré a detallar:
</p>
<pre class="code"> Bit 7 - Control del Display                          (0=Off, 1=On)
  Bit 7 - Control Display (0 = Off, 1 = On)
  Bit 6 - Selection Window Tile Map (0 = 9800-9BFF, 1 = 9C00-9FFF)
  Bit 5 - Window Control (0 = Off, 1 = On)
  Bit 4 - Select Data Tile background and window (0 = 8800-97FF, 1 = 8000-8FFF)
  Bit 3 - Selection Map Tile background (0 = 9800-9BFF, 1 = 9C00-9FFF)
  Bit 2 - Size of the OBJ (Sprites) (0 = 8x8, 1 = 8x16)
  Bit 1 - Control of the OBJ (Sprites) (0 = Off, 1 = On)
  Bit 0 - Control the background (0 = Off, 1 = On)
</pre>

<p>
We will detail the functions of a bit, because this is very important:
</p>

</div>

<h5><a name="bit_7_-_control_del_display" id="bit_7_-_control_del_display">Bit 7 - Control Display</a></h5>
<div class="level5">

<p>
Enables or disables the LCD. The display must be activated before we can show something in it, and sometimes we will want to disable it if we need to write a lot of data on screen as an image or full prensentación end, that time to put all the graphics memory before the display begins to draw graphs and see rare and half things.

<b>WARNING</b> - The display can only be switched on and off when we are in the vertical interval period (V-Blank). Activate or deactivate outside this period may damage the hardware. Very careful about this, because in the emulators nothing happens, but you can spoil your gameboy if you do it in the real hardware. So to enable or disable the LCD, first waiting for the vertical interval (see how to do this). 
</p>

</div>

<h5><a name="bit_0_-_control_del_fondo" id="bit_0_-_control_del_fondo">Bit 0 - Control the background</a></h5>
<div class="level5">

<p>
Bit 0 - Control the background

If this bit is zero, the background is not drawn, it goes blank (with which to draw the background we need to put this bit to one, of course). We have seen this in many games to flicker effects and stuff.
<p></p>
The remaining bits behave similarly and think are explained in the table. 
</p>

</div>

<h4><a name="ff41_-_status_-_status_del_lcd_r_w" id="ff41_-_status_-_status_del_lcd_r_w">$ FF41 - Status - status LCD (R / W)</a></h4>
<div class="level4">

<p>
This record is also very important because it allows us to know who is doing the LCD at all times. We consult for numerous operations, so attentive. It also allows us to activate the LCD breaks, so as you see, we have a lot of functionality in this record.

</p>

<p>
An explanatory table and then we detail:

</p>
<pre class="code">
  Bit 5 - Interrupt Mode 2 OAM (1 = On) (Read / Write)
  Bit 4 - Interrupt Mode 1 V-Blank (1 = On) (Read / Write)
  Bit 3 - Interrupt Mode 0 H-Blank (1 = On) (Read / Write)
  Bit 2 - Match Flag (0: LYC <> LY, 1: LYC = LY) (Read Only)
  Bit 1-0 - Flag Mode (Mode 0-3, see below) (Read Only)
            0: We are in H-Blank
            1: We are in V-Blank
            2: Looking OAM-RAM
            3: Transferring data to LCD
</pre>

<p>
Bytes 3 to 5, let us turn interruptions LCD, very useful for certain processes requiring redrawn fast screen since writing our drawing code in them, we are confident that the drawing will occur properly (especially in Interval periods).
</p>

<p>
Byte 2, serves to compare two special registers, the LY ($ FF44), which is the Y coordinate where the LCD is currently drawing, and the LCY register ($ FF45), we can define us. 
</p>

<p>
Bytes 1 and 0, indicate how the LCD is either in the two periods apart, or by accessing the RAM or writing on the LCD. As we said before, this is very useful to know whether we are in the period of VBlank for example; only would have to see if the bits 1-0 of this register, we have "01", this assembly of the gameboy is as simple as the following:
</p>
<pre class="code asm"><span class="kw1">ld</span>     <span class="kw3">a</span>, <span class="br0">[</span>$FF41<span class="br0">]</span>
<span class="kw1">and</span>    1
<span class="kw1">cp</span>     <span class="nu0">1</span></pre>

<p>
This is loaded in the registry, the value we have in the record status LCD, and do NDA with 1. Any value that has the record, to give and to 1 if positions had in the last 01, the result will be 01, so compared with one (cf. 1). If now the result of the comparison is 0 (same), we are in the period of VBlank.
</p>

<p>
Although there is a faster way to know whether we are in V-Blank, and is using the registration LY I said before. As I said, the registration LY indicates that horizontal line is "drawing" the LCD. From the line 144, the LCD screen is off and therefore are in the vertical interval period. So you are doing this ... 
</p>
<pre class="code asm"><span class="kw1">ld</span>     <span class="kw3">a</span>, <span class="br0">[</span>$FF44<span class="br0">]</span>
<span class="kw1">cp</span>     <span class="nu0">145</span></pre>

<p>
Carry in to the value contained in the registration LY, and compared with 145, if they are equal, just enter VBlank ... as we see, less instruction and assembly, this is very important.

Thus, for example, that you should go see a little assembler gameboy, if we wait until we are in VBlank (to enable or disable the LCD for example, as we saw above), we could do something like: 
</p>
<pre class="code asm">.espera_vblank:
    <span class="kw1">ld</span>     <span class="kw3">a</span>, <span class="br0">[</span>$FF44<span class="br0">]</span>
    <span class="kw1">cp</span>     145
    <span class="kw1">jr</span>     <span class="kw5">nz</span>, .espera_vblank</pre>

<p>
Same as before, but after comparison, if the result is not zero (the LCD is not on the line 145), we jump to the initial label with which we return to do the checking ... this loop would run until the LCD reaches the 145 line, which will continue with the instructions below. Quiet with assembler, we will explain later.
</p>

</div>

<h4><a name="ff42_-_scy_-_scroll_y_r_w_ff43_-_scx_-_scroll_x_r_w" id="ff42_-_scy_-_scroll_y_r_w_ff43_-_scx_-_scroll_x_r_w">$FF42 - SCY - Scroll Y (R/W), $FF43 - SCX - Scroll X (R/W)</a></h4>
<div class="level4">

<p>
Control registers scroll the display, as I explained above, allow us to move the visible window on the background map writing on them. To position the visible area in the coordinate (0,0) of the fund, simply write zero in both records.
</p>

</div>

<h4><a name="ff4a_-_wy_-_posicion_y_de_la_ventana_r_w_ff4b_-_wx_-_posicion_x_de_la_ventana_menos_7_r_w" id="ff4a_-_wy_-_posicion_y_de_la_ventana_r_w_ff4b_-_wx_-_posicion_x_de_la_ventana_menos_7_r_w">$FF4A - WY - Y position of the window (R / W), $ FF4B - WX - Position X of (R / W) Window least 7</a></h4>
<div class="level4">

<p>
Control the x, y position of the window. The window is an alternative fund, which can be drawn above the normal background to effects like zelda status screen. This window has no scroll, but may be positioned in any position by sliding using these registers. If placed in WY = 0, WX = 7, the window cover the entire visible background. The sprites are also above the window.
</p>

</div>

<h3><a name="fondos" id="fondos">Funds</a></h3>
<div class="level3">

<p>

Then we have an area in the VRAM, known as "Background Tile Map" (map tiles background) 32 × 32 = 1024 bytes. Each of these bytes contains a reference to the number tile showing the "Tile Data Table" (data table tiles). Actually we have two background maps, one at $ 9800-9BFF and the other at $ 9C00-9FFF and can select either through the LCDC register ($ FF40).

We also have a "window" that floats above the bottom, controlled by WNDPOSX and WNDPOSY records.

We are also two Data Tables Tile, one that ranges from $ 8000 to 8FFF, unsigned (0-255) and can be used for background, sprites and window, and another going from $ 8800 to $ 97FF, with sign (-128 , 127) and can only be used for backgrounds.

The drawings of the tiles 8 × 8 pixels are stored in the Tile Data Tables using 16 bits per line of the sprite, that is, two bits per pixel to store color data; since in the GameBoy have 4 possible colors: white, light gray, dark gray and black, in binary: 00, 01, 10 and 11 <img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/icon_wink.gif" class="middle" alt=";-)">
</p>

<p>
They are stored in memory as follows:

</p>
<ul>
<li class="level1"><div class="li"> Byte 0-1 - First line (8 pixels) </div>
</li>
<li class="level1"><div class="li"> Byte 2-3 - Second line </div>
</li>
<li class="level1"><div class="li"> …</div>
</li>
<li class="level1"><div class="li"> Byte 14 to 15 - Eighth line.</div>
</li>
</ul>

<p>

Of the two bytes of each line (this is complicated a bit), the first byte, receives the least significant bits of the color of each pixel, and the second the most significant byte being bit 7 more pixel to the left, and 0 pixel on the far right; that is, if the first pixel is dark gray (10) bit 7 of the first byte will be 1 and bit 7 of the second byte will be zero.
</p>

<p>
With a sprite what to draw an "A" multicolored have something like this: 
</p>
<pre class="code">   Tile:                               		Data:

  .33333..				 %01111100 %01111100 -- $7C $7C (Hex)
  22...22.                     		 %11000110 %00000000 -- $C6 $00
  11...11.                     		 %00000000 %11000110 -- $00 $C6
  2222222. &lt;-- digits     		 %11111110 %00000000 -- $FE $00
  33...33.     represent    		 %11000110 %11000110 -- $C6 $C6
  22...22.     colors    		 %11000110 %00000000 -- $C6 $00
  11...11.     		       		 %00000000 %11000110 -- $00 $C6
  ........                		 %00000000 %00000000 -- $00 $00

</pre>

<p>
So if we write 16 bytes $ 7C, $ 7C, $ C6, $ 00, $ 00, $ C6, $ FE, $ 00, $ C6, $ C6, $ C6, $ 00, $ 00, $ C6, $ 00, $ 00 from memory location $ 8000, the tile number 0, will be our "A" multicolored.
</p>

<p>
So now we have the map tiles background, as we said stored in a table of 32 × 32 (1024 bytes) numbers on the tiles to show our virtual screen of 32 × 32 tiles (32 columns x 32 lines) 20 × 18 visible). So, if now in the $ 9800 memory position, we write $ 00, we are saying that in the position tiles wallpaper (0,0), draw the tile 0, activating the LCD, and activate the background, now in the upper left corner of the screen, we would have our "A" multicolored.
</p>

<p>
<strong>IMPORTANT:</strong>
</p>

<p>
Keep in mind that you should not write to the video memory until we are in a period of range (either horizontal or vertical) or disabling the LCD. This is because strange things could happen if we access video memory to write to her, while the LCD is trying to read it ... we'll have to draw flashes and other unwanted effects. The same is true for sprites.
</p>

</div>

<h3><a name="sprites" id="sprites">Sprites</a></h3>
<div class="level3">

<p>

In addition to funds, of course we have the sprites. Sprites are graphics objects moving above the bottom, have a transparent color, and properties that can apply them as horizontal and vertical reflection. Normally the sprites are used to draw our characters, ships, enemies, and any graphic object that we want to handle regardless of background.
</p>

<p>
 The video controller of the GameBoy, can draw sprites in modes 40 8 × 8 or 8 × 16 px px, though a hardware limitation, 10 sprites can be drawn simultaneously in a horizontal line (just 10 sprites can share the same coordinate Y). The graphics of the sprites are stored in memory in the same format as useful background in the table known as Sprite Pattern Table (Table patterns sprites), between $ 8000-8FFF memory locations, which can define up to 256 sprites (4096 bytes / 16 bytes per sprite). As we saw earlier, the $ 8,000 address is also used by the data table tiles background, so if the graphics for tiles and sprites are shared, we must take this into account when we design our graphics.
</p>

<p>
The attributes of the sprites, the sprites table that defines that we will use and how we use, reside in the Sprite Atributte Table, between memory locations $ FE00-FE9F. Each of these entries consists of 4 bytes, which have 160/4 = 40 entries, as stated above.
</p>

<p>
Each entry is made up as follows:
</p>

</div>

<h5><a name="byte_0_-_coordenada_y" id="byte_0_-_coordenada_y">Byte 0 - Y coordinate</a></h5>
<div class="level5">

<p>
Specifies the Y position of the sprite least 8. How ?, the first visible pixel on the screen is vertically 8, this is so that we can put a little sprite or completely off the screen, drawing it between the 0-7 positions . Likewise we can get him out of the screen by drawing it into higher positions down to 140. 
</p>

</div>

<h5><a name="byte_1_-_coordenada_x" id="byte_1_-_coordenada_x">Byte 1 - X coordinate</a></h5>
<div class="level5">

<p>
Specifies the X position of the sprite least 8. The same applies to the Y position unless we have 160 pixels visible on X coordinate 
</p>

</div>

<h5><a name="byte_2_-_numero_de_sprite" id="byte_2_-_numero_de_sprite">Byte 2 - Number of sprite</a></h5>
<div class="level5">

<p>
 Specifies the sprite number to use for this entry sprites defined in Table $ 8000-8FFF. 
</p>

</div>

<h5><a name="byte_3_-_atributos" id="byte_3_-_atributos"> Byte 3 - Attributes </a></h5>
<div class="level5">

<p>
Specifies the special attributes that can be applied to a sprite. Each bit of this byte is a flag that applies different sprite modifications according to the following table: 
</p>
<pre class="code">
  Bit7 Priority (0 = Sprite above the bottom, 1 = Object below background colors 1-3)
         (Valid for the background and the window. The color background 0 is always behind the sprite (transparent))
  Reflection Bit6 Y (0 = Normal, 1 = Vertical mirroring)
  Bit5 Reflection X (0 = Normal, 1 = Horizontal Mirrored)
  Bit4 Number of pallet ** Color not only in GB ** (0 = OBP0, 1 = OBP1)
  Bit3 VRAM Bank ** ** Only GB Color (0 = Bank 0, 1 = Bank 1)
  Bit2-0 palette number ** ** Only GB Color (OBP0-7)
</pre>

<p>
As we see, several bits are only applicable to <acronym title="Gameboy">GB</acronym> Color, so for now we ignore it and focus on the priority, and mirrored palette. 
</p>

</div>

<h1><a name="herramientas" id="herramientas">Tools</a></h1>
<div class="level1">

</div>

<h3><a name="ensamblador" id="ensamblador">Assembler</a></h3>
<div class="level3">

<p>
To program in assembler for GameBoy, the first thing we need, what is it? As an assembler, the program that converts our written in assembly code to machine code gameboy, as a ROM that can run our favorite emulator or loaded directly into our Gameboy with flashcart. 
</p>

<p>
Personally, I use the RGBDS, a development system specific assembly for GameBoy, so everything is very easy with him. The can download it from here: 
</p>

<p>
<strong>Windows</strong>: There are builds for windows in:<a href="http://anthony.bentley.name/rgbds/" class="urlextern" title="http://anthony.bentley.name/rgbds/" rel="nofollow">http://anthony.bentley.name/rgbds/</a>
</p>

<p>
The descargais and you copy the .exe c: \ windows or the like within the PATH
</p>

<p>
<strong>Gnu/Linux</strong>: For a while, the RGBDS for Unix is hosted on GitHub: <a href="https://github.com/bentley/rgbds" class="urlextern" title="https://github.com/bentley/rgbds" rel="nofollow">https://github.com/bentley/rgbds</a>
</p>

<p>
In gnu/linux you have to compile it, but come on, it is simply run as root, a "make install" after downloading the git directory.
</p>

<p>
RGBDS you have documentation in: <a href="http://anthony.bentley.name/rgbds/manual/rgbds/" class="urlextern" title="http://anthony.bentley.name/rgbds/manual/rgbds/" rel="nofollow">http://anthony.bentley.name/rgbds/manual/rgbds/</a>
</p>

<p>
Well, RGBDS comes with four tools, <strong>rgbasm</strong>, the assembler itself,  <strong>rgblink</strong>, the linker will create our roms, the  <strong>rgblib</strong> to create libraries, and  <strong>rgbfix</strong> to modify the head of the ROM, so that it meets the necessary requirements ROM to run. As we saw in the introduction, the head of a GameBoy ROM, takes several checksums and others, because this tool adjusted so that the rom is correct.
</p>

<p>
 Also need some files that will make us easier to assemble the item and generate our roms, I will leave them below: 
</p>

<p>
<strong>Windows</strong>: <a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=assemble.bat" class="media mediafile mf_bat" title="assemble.bat">assemble.bat</a>
</p>

<p>
<strong>Gnu/Linux</strong>: <a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=assemble.sh" class="media mediafile mf_sh" title="assemble.sh">assemble.sh</a>
</p>

<p>
<strong>NOTE</strong> - The source code, you must take the extension .agb (assembler gameboy) to run these scripts.
</p>

<p>
And finally, one more important help, a file that you can include in your source code that defines names for all records and memory addresses of the gameboy, and some support as the head of the ROM, etc.
</p>

<p>
You can download it here: <a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=gbhw.inc" class="media mediafile mf_inc" title="gbhw.inc">gbhw.inc</a>
</p>

</div>

<h3><a name="editor" id="editor">Editor</a></h3>
<div class="level3">

<p>

also you will need an editor for your source code. I personally use VIM, and have defined a syntax file for assembler files .agb gameboy, if someone wants it can download it here: <a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=agb.vim">agb.vim</a> , and install it in your ~ / .vim / syntax /. Remember to add the following line to your .vimrc that you recognize this extension:
</p>
<pre class="code">au BufRead,BufNewFile *.agb set filetype=agb</pre>

<p>

Also I have a syntax file for .agb for Gedit files: <a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=agb.lang" class="media mediafile mf_lang" title="agb.lang">agb.lang</a>, you can install it in ~ / .local / share / gtksourceview-3.0 / language-specs (cread the directory if not exist)
</p>

<p>
If vim is too much for you (for now), you can try Notepad ++, which supports assembler. <a href="http://notepad-plus-plus.org/es/home" class="urlextern" title="http://notepad-plus-plus.org/es/home" rel="nofollow">http://notepad-plus-plus.org/es/home</a>
</p>

</div>

<h3><a name="emulador" id="emulador">Emulator</a></h3>
<div class="level3">

<p>

Also, to start testing your programs, it is best emulator. There are many GameBoy emulators available, although I recommend the BGB, works on both Windows and Linux using the Wine (in Options → Graphics, select DirectDraw or OpenGL output if you have problems with the image), and is truly faithful to the original machine, so you bear no surprises when you run your gameboy roms on a real, and different things work emulator. It also has an integrated debugger, displays tables tiles and sprites, disassembler ... cane. You can download it here: 
<a href="http://bgb.bircd.org/" class="urlextern" title="http://bgb.bircd.org/" rel="nofollow">http://bgb.bircd.org/</a>
</p>

<p>
Also works great VisualBoyAdvance GameBoy emulating, and the latest versions include GUI and some tools like power off graphic layers, sound channels, etc.
</p>

</div>

<h1><a name="hola_mundo" id="hola_mundo">Hello World</a></h1>
<div class="level1">

<p>

 Let's make a small example program, a small hello world, that we can execute our gameboy, and show a little smiling face on screen. Then, step by step, I will explain the program's instructions. Let's do this: 
</p>

<p>
First let's draw our sprite as we learned earlier: 
</p>
<pre class="code">  .33333..				 %01111100 %01111100 -- $7C $7C 
  3111113.                     		 %10000010 %11111110 -- $82 $FE
  31.1.13.                     		 %10000010 %11010110 -- $82 $D6
  31.1.13.               		 %10000010 %11010110 -- $82 $D6
  3111113.               		 %10000010 %11111110 -- $82 $FE
  3.111.3.              		 %10000010 %10111010 -- $82 $BA
  31...13.     		       		 %10000010 %11000110 -- $82 $C6
  .33333..                		 %01111100 %01111100 -- $7C $7C
</pre>

</div>

<h3><a name="codigo" id="codigo">Code</a></h3>
<div class="level3">

<p>

Taking this data to draw our smiling face, we started with the program:

</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=13" title="Descargar trozo de código fuente" class="mediafile mf_asm">holamundo.asm</a></dt>
<dd><pre class="code asm"><span class="co1">;  Hello World</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; For the tutorial (In Spanish): </span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span>
&nbsp;
<span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>          <span class="co1">; import file definitions</span>
&nbsp;
&nbsp;
<span class="co1">; The Program Begins Here</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>      inicio
&nbsp;
<span class="co1">;  Head of the ROM (Macro defined in gbhw.inc)</span>
<span class="co1">; defines a rom without mapper, without 32K RAM, the basics</span>
<span class="co1">; (Such as tetris)</span>
    ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE
&nbsp;
<span class="co1">; here begins are program</span>
inicio:
    <span class="kw1">nop</span>
    <span class="kw1">di</span>                      <span class="co1">; disables interrupts</span>
    <span class="kw1">ld</span>      <span class="kw3">sp</span>, $ffff       <span class="co1">; We aim pile atop the ram</span>
&nbsp;
inicializacion:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %11100100    <span class="co1">; Palette colors from the darkest to</span>
                            <span class="co1">; Lighter, 11 10 01 00</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; We write this in the palette register</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; write 0 records scroll in X and Y</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; positioned so that the visible screen</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; at the beginning (upper left) of the fund.</span>
&nbsp;
    <span class="kw1">call</span>    apaga_LCD       <span class="co1">; We call the routine that turns off the LCD</span>
&nbsp;
    <span class="co1">;  We load the tile in memory of tiles</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, TileCara    <span class="co1">; HL loaded in the direction of our tile</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _VRAM       <span class="co1">; address in the video memory</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="nu0">16</span>           <span class="co1">; b = 16, number of bytes to copy</span>
&nbsp;
.bucle_carga:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>          <span class="co1">;  A load in the data pointed to by HL</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>         <span class="co1">; and we put in the address pointed in DE</span>
    <span class="kw1">dec</span>     <span class="kw3">b</span>               <span class="co1">; decrement b, b = b-1</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_bucle_carga <span class="co1">;  if b = 0, finished, nothing left to copy</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">; We increased the read direction</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>              <span class="co1">; We increased the write direction</span>
    <span class="kw1">jr</span>      .bucle_carga    <span class="co1">; we follow</span>
.fin_bucle_carga:
&nbsp;
    <span class="co1">;  We write our tile, tiles on the map</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SCRN0      <span class="co1">; HL in the direction of the background map</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, $00       <span class="co1">; $00 = tile 0, our tile.</span>
&nbsp;
    <span class="co1">; configure and activate the display</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJOFF
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; infinite loop</span>
bucle:
    <span class="kw1">halt</span>
    <span class="kw1">nop</span>
    <span class="kw1">jr</span>      bucle
&nbsp;
<span class="co1">; LCD shutdown routine</span>
apaga_LCD:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
    <span class="kw1">rlca</span>                    <span class="co1">; It sets the high bit of LCDC in the carry flag</span>
    <span class="kw1">ret</span>     <span class="kw5">nc</span>              <span class="co1">; Display is already off, again.</span>
&nbsp;
    <span class="co1">; We VBlank hope to, because we can not turn off the screen</span>
    <span class="co1">; some other time</span>
&nbsp;
.espera_VBlank
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .espera_VBlank
&nbsp;
    <span class="co1">; we are in VBlank, we turn off the LCD</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>       <span class="co1">;in A, the contents of the LCDC</span>
    <span class="kw1">res</span>     7,<span class="kw3">a</span>             <span class="co1">; we zero bit 7 (on the LCD)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>       <span class="co1">; We wrote in the LCDC register content A</span>
&nbsp;
    <span class="kw1">ret</span>                     <span class="co1">; volvemos</span>
&nbsp;
<span class="co1">;  Our tile data</span>
TileCara:
    <span class="kw4">DB</span>  $7C, $7C, $82, $FE, $82, $D6, $82, $D6
    <span class="kw4">DB</span>  $<span class="nu0">82</span>, $FE, $<span class="nu0">82</span>, $BA, $<span class="nu0">82</span>, $C6, $7C, $7C
EndTileCara:</pre>
</dd></dl>

<p>
Well, there's our hello world. Save it as hola.agb, and compile using the bat or sh that you descargasteis follows: assemble.sh (or assemble.bat) hello hola.agb The same search for the file and ensablará and create the rom. Deberiais now have a hola.gb that if you execute on your emulator or gameboy, you will see a smiling face in the upper left corner of the screen. Well, actually, if the emulator is good, or you execute in real gameboy, it is likely that the screen is filled with these smileys except perhaps the Nintendo logo. Why ?, because we have not cleaned the video memory and other things with which we will improve the sample program.
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=bgb00001.png" class="media" title="bgb00001.png"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch_003.png" class="media" alt=""></a>
</p>

</div>

<h3><a name="explicacion" id="explicacion">Explanation</a></h3>
<div class="level3">

<p>

Well, we split ...
</p>
<pre class="code asm"><span class="co1">; Hello World</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; for the tutorial(Spanish): </span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span></pre>

<p>
 Well, in assembly, the code comments starting with ";". As you know, the comments are for adding explanations and documentation to our code for others or us after a while, we know that such and such a routine schedule, etc. So simply, the assembler ignores the text of a line from a semicolon to the end of it.
</p>
<pre class="code asm"><span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>          <span class="co1">; import file definitions</span></pre>

<p>
INCLUDE, assembler is a command that you do is import the file code word for it, from the time this command appears; that is, it is as if we took the code in "gbhw.inc" and then beat her. This is useful, because we can have code that used the same spot separate files, and import from all our programs, thus saving type them or copy each. As we see later in the line, a comment appears, so from ";" to the end of the line, this text is ignored. 
</p>
<pre class="code asm"><span class="co1">; The program begins here</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>      inicio</pre>

<p>
SECTION defines a section of code, as its name suggests, a block of code you want to define and place in a specific memory location. The assembler RGBDS allows us to define him a name "start" and a start address, address from which, put that code in memory. In the GameBoy, we have seen in the memory map, the ROM cartridge, where to go our own code, starts at $ 0000, but the first 256 bytes ($ 100) are reserved for interrupt routines, so we placing our code from the address $ 0100, so we put the "start" section from HOME ($ 0000) + $ 100. Then we executed a nop, GBZ80 this instruction does nothing, literally (no operation). It serves to waste time (4 cycles) or data blocks to fill gaps that need (1 byte). Then execute the instruction jp, used to make jumps from one place to another program, you can define conditions for the jump or not. In this case, no conditions, and we say that simply jump to the label Start. Why do we do this? Well, if we look at the documentation on organizazión a ROM GameBoy, we see that the head of the ROM should start in the $ 0104 address, so if we put a nop (1 byte), then jp <address> command ( 3 bytes), we are filling 4 bytes, just what we need to begin defining the header, which will introduce the next thing. But we need that jp, to jump from here, to begin to execute code as the header data will not executable code. 
</p>
<pre class="code asm"><span class="co1">; Head of the ROM (Macro defined in gbhw.inc)</span>
<span class="co1">; defines a rom without mapper, without 32K RAM, the basics</span>
<span class="co1">; (Such as tetris)</span>
    ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE</pre>

<p>
 ROM_HEADER This is a macro defined in the gbhw.inc. Macros are special constructions RGBDS that allow us to define certain blocks of code and modify using parameters. We can assume that with this, the RGBDS introduce us here the necessary bytes of the header of the cartridge, without having to worry about defining them by hand. You can take a look at the end of gbhw.inc if you have curiosity.
</p>
<pre class="code asm"><span class="co1">; Here begins our program</span>
inicio:
    <span class="kw1">nop</span>
    <span class="kw1">di</span>                      <span class="co1">;  disables interrupts</span>
    <span class="kw1">ld</span>      <span class="kw3">sp</span>, $ffff       <span class="co1">; We aim pile atop the ram </span></pre>

<p>
Well, we start with the topic. First a nop, we already know, then with the di instruction, we disable interrupts, not going to use in this example, and only bother us. Then we loaded in the SP register stack pointer, the address $FFFF which is the top of the ram of the gameboy. The stack is used to store temporary data we need, as the return addresses when a subroutine call. Furthermore, the stack grows downward directions. So now, if we keep a byte on the stack, SP is decremented, which is worth $fffe and the byte is stored there. If now we take a byte of the stack, it returns the data in $ fffe and increases SP, again pointing to $ffff.
</p>
<pre class="code asm">inicializacion:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %11100100    <span class="co1">; Palette colors from the darkest to</span>
                            <span class="co1">; Lighter, 11 10 01 00</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; We write this in the palette register</span></pre>

<p>
 We define a label "initialization" and started writing the code that will put our gameboy to work properly. First palette. As we know the classic GameBoy has 4 colors, white, black and two shades of gray. We can define two paddles, come on, order these four colors as you want, for one to be the first, another the second, etc. We also have two possible palettes. This is fine, because we also have such an inverted paddle effects or things like that. But for now we will use only the lightest (00) very average palette, darker colors (11). Then with the ld instruction, one of the most important and most usareis Gameboy assembly (basically because it serves to move data from one side to another of many possible ways), we loaded in the "a", the palette data (% 11100100 in binary). The ld instruction, is built basically as follows, ld <destination> <source>, where destination and origin can be registers, memory addresses or direct numbers. 
</p>

<p>
Now with another ld, loaded in the memory address pointed to by rBGP (gbhw.ic if we look, we see that rBGP is a normal memory address), the contents of register "a"; rBGP bracketed because what we mean is that stored in that memory address. 
</p>

<p>
We will explain this: If we have the record "a", contains the number 200, and we "ld a, 5", now "a" contains 5. But if instead we "ld [a], 5" I we are doing is recorded in the memory location pointed to by "a", the value 5, which would write 5 in the memory 200 (which was the value it had "a" at the beginning). 
</p>
<pre class="code asm">    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; write 0 records scroll in X and Y</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; positioned so that the visible screen</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; at the beginning (upper left) of the fund. </span></pre>

<p>
Well, right ?, simple as we have seen, simply load the registry to 0 (a = 0) and then to write the content, records vertical and horizontal scroll, which are now worth 0, positioning the screen top left of the background map. Notice that we use the brackets, to refer to, writes this data in the memory location pointed to by RSCX and rSCY.
</p>
<pre class="code asm">    <span class="kw1">call</span>    apaga_LCD       <span class="co1">; We call the routine that turns off the LCD </span></pre>

<p>
Here to call, <strong>call</strong> a subroutine. Assembler subroutines are the functions in C or other programming language. They are blocks of code that perform specific operations and when they finish, they return to where they were called. The assembly will seek a label called apagaLCD, jump there, and execute the code that is then until you find the <strong>ret</strong> instruction, which returns to the point where the subroutine was called. Unlike in C or other languages, if we want to pass parameters to subroutines, we have to do it ourselves, worrying about keeping certain data in registers or on the stack before calling the subroutine, and be careful not to undesirably change records we are using outside the subroutine, a common mistake that can give us good headaches.
</p>
<pre class="code asm">    <span class="co1">; We load the tile in memory of tiles</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, TileCara    <span class="co1">; HL loaded in the direction of our tile</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _VRAM       <span class="co1">; address in the video memory</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="nu0">16</span>           <span class="co1">; b = 16, numero de bytes a copiar</span>
&nbsp;
.bucle_carga:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>          <span class="co1">; A load in the data pointed to by HL</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>         <span class="co1">; and we put in the address pointed in DE</span>
    <span class="kw1">dec</span>     <span class="kw3">b</span>               <span class="co1">; decrement b, b = b-1</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_bucle_carga <span class="co1">; if b = 0, finished, nothing left to copy</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">;  We increased the write direction</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>              <span class="co1">; We increased the write direction</span>
    <span class="kw1">jr</span>      .bucle_carga    <span class="co1">; We Follow</span>
.fin_bucle_carga:</pre>

<p>
Well, come with something interesting, since we will show how things are done especially loops in assembly. With this code we will load into memory tiles, the 16 bytes that define our smiling face. We could do so simply by loading instructions ld byte by byte ... we would load a byte to for example, and then would load the contents of a, a memory address of the start of memory tiles, then the next, etc ... but imagine we have to charge 50 tiles ... as not. For loops that are, as in any programming language. Let's see how we do.
</p>

<p>
First, we start by initializing certain data records. We charge in hl (log 16 bit), the address where the bytes are our tile. If we use a label in a ld instruction, the assembler replaces it with the memory address where the code or data after the label begins. We have to use a 16-bit register, because as we have seen, GBZ80 memory addresses are 16 bits.
</p>

<p>
After the registration charge, the direction of video memory, which starts at $ 8000 and as we have seen, is the starting address of the memory of tiles.
</p>

<p>
And now loaded in the register b, the number 16, which are the bytes that have to be copied.
</p>

<p>
 Now we start with the loop. We put a label at the beginning of the loop, because we have to go back to it at each "round" of the loop. Well, carry on to the data pointed to by hl, hl as we know is the address where the data from our sprite begin. So with this instruction, we carry in to the first byte of our tile. Now get into the address pointed to by the contents of a, with what we already have the first byte of our tile, copied to the first memory address of tiles. Now we decrease b, using instruction <strogn>dec</strong>, which simply subtracts a unit to record to say it. As we have copied a byte, and because there are only 15 per copy, so subtract one ab, to reflect this.
</p>

<p>
And now comes the main logic loop. Jr z, .fin_bucle_carga, what we do is, "jumps .fin_bucle_carga if the result of the previous operation was zero." As we saw in the section flags, z zero meant that the flag had been activated. So if the result of the above operation, dec b is zero, we jumped out of the loop, because we have finished copying. It is simple, at each turn of the loop, let ab subtracting one, so when we copied the 16 bytes, b will be zero, the flag and the z jz is activated, it will jump out.
</p>

<p>
 If the zero flag is not set, because b still is not zero, then the jump does not occur, and the execution follows. Now with <strong>inc</strong>, we increase (add one) and HL. We do this, because as we have already copied the first data to the first memory address of tiles, now we have to continue with the second, third, etc., so that each time through the loop, we increased these two directions, pointing to Iran following directions of our data and useful memories positions respectively. And finally, we jump to .bucle_carga to copy the following until b is zero, which will jump to .fin_bloque_carga, finishing our loop.
</p>
<pre class="code asm">    <span class="co1">; We write our tile, tiles on the map</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SCRN0      <span class="co1">;HL in the direction of the background map</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, $00       <span class="co1">; $00 = tile 0, our tile. </span></pre>

<p>
This is very simple compared to this. Simply load in the direction hl map tiles background, and then write in this direction, the zero byte, indicating that the 0.0 tile map background, tile is zero, the first tile of the table, which as you know, just we write on the board tiles.
</p>
<pre class="code asm">    <span class="co1">; configure and activate the display</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJOFF
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span></pre>

<p>
 Nothing, we've got the data from our tile at the beginning of the memory of tiles, so is the zero tile, and have written a zero in the first position of the background map, which the first tile background ( 0.0 top left) corner is our sprite. So now we can turn the LCD to see our creation. What we do is upload to, lcd certain configurations, which are defined in the gbhw.inc. making an OR (|) between these settings, select all, LCDCF_ON (LCD on), LCDCF_BG8000 (tile data in $ 8000), LCDCF_BG9800 (tile map in $ 9,800), LCDCF_BGON (on background) LCDCF_OBJ8 (sprites 8 × 8) , LCDCF_OBJOFF (sprites off). And then we wrote in the memory of the control register LCD, which apply that configuration. From here, we would have our tile on the screen.
</p>
<pre class="code asm">    <span class="co1">; infinite loop</span>
bucle:
    <span class="kw1">halt</span>
    <span class="kw1">nop</span>
    <span class="kw1">jr</span>      bucle</pre>

<p>
Well, in assembly, we arrived at an impasse, we must make an infinite loop. Why ?, because if not, he would continue processor running code that we have not written, let the following memory locations after our code, we do not know containing (typically random values), so anything could happen. So far, our program has ended, and we will not do anything else, we created this infinite loop that runs until we turn the console or the batteries run out<img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/icon_smile.gif" class="middle" alt=":-)">
</p>

<p>
It's simple, make a halt, putting the processor in low power mode and stops executing until an interrupt occurs. As might get interruptions, because then we do a nop (nothing) and jump to the beginning of the loop again, so we could stay here forever. 
</p>
<pre class="code asm"><span class="co1">; LCD shutdown routine</span>
apaga_LCD:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
    <span class="kw1">rlca</span>                    <span class="co1">;It sets the high bit of LCDC in the carry flag</span>
    <span class="kw1">ret</span>     <span class="kw5">nc</span>              <span class="co1">;  Display is already off, again.</span>
&nbsp;
    <span class="co1">; We VBlank hope to, because we can not turn off the screen</span>
    <span class="co1">; some other time</span>
&nbsp;
.espera_VBlank
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .espera_VBlank
&nbsp;
    <span class="co1">; we are in VBlank, turn off the LCD </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>       <span class="co1">;  in A, the contents of the LCDC </span>
    <span class="kw1">res</span>     7,<span class="kw3">a</span>             <span class="co1">; we zero bit 7 (on the LCD)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>       <span class="co1">;  We wrote in the LCDC register content A</span>
&nbsp;
    <span class="kw1">ret</span>                     <span class="co1">; return</span></pre>

<p>
Well, our program has ended, but then we can write data or subroutines that can be called or used by your code if the main program makes them reference system. This is the case of routine apaga_LCD, we had called from the main program with the <strong>call</strong> command.
</p>

<p>
Let's analyze it. The first thing we do is to upload the contents of LCD control register, rLCDC. Now we run the <strong>rclr</strong> order. It is a peculiar order, making it is to bit 7 of registration in the carry flag. For what it this? as for checks, of course, it is what we do next. As we mentioned, the ret instruction, exits the subroutine and returns execution to where he was allowed to call, but ret. You can also accept conditions to return or not, depending upon a flag.In this case we check the carry flag, if it is exactly zero. ret nc, it means "return if the carry flag is zero". In the carry flag we had set bit 7 of rLCDC, and if we look which means that bit in the video section, we see that means if the LCD is on or off. What will you see, we could then translate as "returns if the LCD is off," Come on, that does not make sense off the LCD if it is already off, therefore, if it is already back and our subroutine does nothing.
</p>

<p>
If it was not off, the bit 7 of rLCDC would be worth 1 and therefore the ret not be executed, so that the execution would continue. Okay, now, as we saw, it was very important not to turn the LCD while you were not in the vertical interval, as this may damage. So it's what we do now. RLY check the registry to see what is drawing the line LCD, if it is 145, it means you're out of the screen in the vertical interval, and we can continue. If not, we wait until rLY is 145.
</p>

<p>
Now turn off the LCD, load the contents of rLCDC in to, and the instruction must beef , which resets (resets) the bit to let him log, resets the bit 7, which as we know turned on or off LCD. Now we rewrite the content of a in rLCDC, so we changed the bit 7 without affecting the rest of the content of rLCDC. 
</p>

<p>
 The LCD is turned off, so that we can return to ret. 
</p>
<pre class="code asm"><span class="co1">; Our tile data</span>
TileCara:
    <span class="kw4">DB</span>  $7C, $7C, $82, $FE, $82, $D6, $82, $D6
    <span class="kw4">DB</span>  $<span class="nu0">82</span>, $FE, $<span class="nu0">82</span>, $BA, $<span class="nu0">82</span>, $C6, $7C, $7C
EndTileCara:</pre>

<p>
And here, then we write the data from our sprite.It is common to put data between labels significant, and also add a label to the end. Now we know we have 16 tiles, but if we had many, instead of counting them, we could tell the assembler to load EndTileCara-TileCara bytes, so that the assembler would count how many bytes between these addresses and would replace that value in our program. So it is well accustomed to this.
</p>

<p>
 As you see, we put our data which such sprite, separated by commas, and predicted by the DB directive, Byte Defines which simply inserts those values ​​in the memory of our program as is, to use as data. 
</p>

<p>
 For things how are you, you said it was important the infinite loop at the end of our program, because otherwise he would follow program running anything that could be next, and could interpret graphics data, music, or text, as if they were instructions, so anything could happen <img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/icon_smile.gif" class="middle" alt=":-)">
</p>

<p>
 And even here our example program, that, as you have seen their small mistakes (on purpose), so you can see to be initialized good memories. 
</p>

</div>

<h3><a name="mejoras" id="mejoras">Improvements</a></h3>
<div class="level3">

<p>
So now, let's apply a couple of improvements to our program, I explain what I do, then good for him I commented estudieis understand code and treat them as I leave.First, I will define another tile, tile zero, it will be a totally white tile, and with it, I'll fill the background map before doing anything. Whereby, as will suppose, I will remove all the blank screen. After simply I will change the tile that will draw to 0.0 by the tile 1, because now our happy face will be the second tile, and draw it, otherwise the program will be the same.
</p>

<p>
I leave the code: 
</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=28" title="Descargar trozo de código fuente" class="mediafile mf_asm">holamundo2.asm</a></dt>
<dd><pre class="code asm"><span class="co1">; Hello world improved</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; For The tutorial(Spanish): </span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span>
&nbsp;
<span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>          <span class="co1">; import file definitions</span>
&nbsp;
&nbsp;
<span class="co1">; The program begins here:</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>      inicio
&nbsp;
<span class="co1">;  Head of the ROM (Macro defined in gbhw.inc)</span>
<span class="co1">; defines a rom without mapper, without 32K RAM, the basics</span>
<span class="co1">; (Such as tetris)</span>
    ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE
&nbsp;
<span class="co1">; Here begins our program</span>
inicio:
    <span class="kw1">nop</span>
    <span class="kw1">di</span>                      <span class="co1">; disables interrupts </span>
    <span class="kw1">ld</span>      <span class="kw3">sp</span>, $ffff       <span class="co1">; We aim pile atop the ram</span>
&nbsp;
inicializacion:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %11100100    <span class="co1">;  Palette colors from the darkest to</span>
                            <span class="co1">; Lighter, 11 10 01 00</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; We write this in the palette register</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; write 0 records scroll in X and Y </span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; whereby the visible screen positioned</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">;  at the beginning (upper left) of the fund.</span>
&nbsp;
    <span class="kw1">call</span>    apaga_LCD       <span class="co1">; We call the routine that turns off the LCD</span>
&nbsp;
    <span class="co1">; We load the tiles in memory of tiles</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Tiles       <span class="co1">; HL loaded in the direction of our tile</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _VRAM       <span class="co1">; address in the video memory</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="nu0">32</span>           <span class="co1">; b = 32, number of bytes to copy (2 tiles)</span>
&nbsp;
.bucle_carga:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>          <span class="co1">; A load in the data pointed to by HL</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>         <span class="co1">;  and we put in the address pointed in DE </span>
    <span class="kw1">dec</span>     <span class="kw3">b</span>               <span class="co1">; decrement b, b = b-1</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_bucle_carga <span class="co1">; if b = 0, finished, nothing left to copy</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">; We increased the read direction</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>              <span class="co1">;  We increased the write direction</span>
    <span class="kw1">jr</span>      .bucle_carga    <span class="co1">; we follow</span>
.fin_bucle_carga:
&nbsp;
    <span class="co1">; We clean the screen (fill entire background map), with tile 0</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SCRN0
    <span class="kw1">ld</span>      <span class="kw3">de</span>, <span class="nu0">32</span>*<span class="nu0">32</span>       <span class="co1">; number of tiles on the background map</span>
.bucle_limpieza:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">;  tile 0 is our empty tile </span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">dec</span>     <span class="kw3">de</span>
    <span class="co1">;  Now I have to check if 'from' is zero, to see if I have it </span>
    <span class="co1">; finishes copying. DEC does not modify any flag, so I can not</span>
    <span class="co1">; check the zero flag directly, but to 'of' zero, dye</span>
    <span class="co1">; They must be zero two, so I can make or including</span>
    <span class="co1">; and if the result is zero, both are zero.</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">d</span>            <span class="co1">;  d loaded in to</span>
    <span class="kw1">or</span>      <span class="kw3">e</span>               <span class="co1">; and make a or e</span>
    <span class="kw1">jp</span>      <span class="kw5">z</span>, .fin_bucle_limpieza  <span class="co1">; if d or e is zero, it is zero.  We ended.</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">; We increased the write direction</span>
    <span class="kw1">jp</span>      .bucle_limpieza
.fin_bucle_limpieza
&nbsp;
    <span class="co1">; Well, we have all the map tiles filled with tile 0,</span>
    <span class="co1">;We can now paint ours</span>
&nbsp;
    <span class="co1">; We write our tile, tiles on the map</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SCRN0      <span class="co1">; HL in the direction of the background map </span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, $01       <span class="co1">; $01 = the tile 1, Our tile. tile.</span>
&nbsp;
    <span class="co1">; configure and activate the display </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJOFF
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; infinite loop</span>
bucle:
    <span class="kw1">halt</span>
    <span class="kw1">nop</span>
    <span class="kw1">jr</span>      bucle
&nbsp;
<span class="co1">; LCD shutdown routine</span>
apaga_LCD:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
    <span class="kw1">rlca</span>                    <span class="co1">; It sets the high bit of LCDC in the carry flag</span>
    <span class="kw1">ret</span>     <span class="kw5">nc</span>              <span class="co1">; Display is already off, again.</span>
&nbsp;
    <span class="co1">; We VBlank hope to, because we can not turn off the screen</span>
    <span class="co1">; some other time</span>
&nbsp;
.espera_VBlank
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .espera_VBlank
&nbsp;
    <span class="co1">; we are in VBlank, turn off the LCD </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>       <span class="co1">; in A, the contents of the LCDC </span>
    <span class="kw1">res</span>     7,<span class="kw3">a</span>             <span class="co1">;  we zero bit 7 (on the LCD)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>       <span class="co1">; We wrote in the LCDC register content A</span>
&nbsp;
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
&nbsp;
<span class="co1">; Our tiles Facts</span>
Tiles:
    <span class="kw4">DB</span>  $00, $00, $00, $00, $00, $00, $00, $00
    <span class="kw4">DB</span>  $00, $00, $00, $00, $00, $00, $00, $00
    <span class="kw4">DB</span>  $7C, $7C, $82, $FE, $82, $D6, $82, $D6
    <span class="kw4">DB</span>  $<span class="nu0">82</span>, $FE, $<span class="nu0">82</span>, $BA, $<span class="nu0">82</span>, $C6, $7C, $7C
EndTiles:</pre>
</dd></dl>

<p>
And the result, this time if: 
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=bgb00002.png" class="media" title="bgb00002.png"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch_004.png" class="media" alt=""></a>
</p>

</div>

<h1><a name="hola_sprites" id="hola_sprites">Hello sprites</a></h1>
<div class="level1">

<p>
Well, now let's change the hello world, to create and manage a sprite. First, I will create another than white tile, tile will be a soft background, so you can see as the sprite moves over smoothly.Then I'll do this, I will initiate the gameboy, and hello world, but adding a palette also for sprites (I'll use it), I will fill the background with a soft tile, and then I'll create a sprite, and go moving bounced around the screen . I will use a small delay routine so that everything goes slower. Let's see the code:
</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=29" title="Descargar trozo de código fuente" class="mediafile mf_asm">holasprite.asm</a></dt>
<dd><pre class="code asm"><span class="co1">; Hello sprite</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; For the tutorial(spanish): </span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span>
&nbsp;
<span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>          <span class="co1">; We define constants to work with our sprite</span>
&nbsp;
<span class="co1">; We define constants to work with our sprite</span>
_SPR0_Y    <span class="kw4"> EQU</span>     _OAMRAM <span class="co1">; sprite Y 0 is the beginning of the sprite mem</span>
_SPR0_X    <span class="kw4"> EQU</span>     _OAMRAM+1
_SPR0_NUM  <span class="kw4"> EQU</span>     _OAMRAM+2
_SPR0_ATT  <span class="kw4"> EQU</span>     _OAMRAM+<span class="nu0">3</span>
&nbsp;
<span class="co1">; We create a couple of variables to see where we need to move the sprite</span>
_MOVX      <span class="kw4"> EQU</span>     _RAM    <span class="co1">; start of RAM for data dispobible</span>
_MOVY      <span class="kw4"> EQU</span>     _RAM+<span class="nu0">1</span>
&nbsp;
<span class="co1">; The program begins here:</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>      inicio
&nbsp;
<span class="co1">; Head of the ROM (Macro defined in gbhw.inc)</span>
<span class="co1">; defines a rom without mapper, without 32K RAM, the basics</span>
<span class="co1">; (Such as tetris)</span>
    ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE
&nbsp;
<span class="co1">; Here begins our program</span>
inicio:
    <span class="kw1">nop</span>
    <span class="kw1">di</span>                      <span class="co1">; disables interrupts </span>
    <span class="kw1">ld</span>      <span class="kw3">sp</span>, $ffff       <span class="co1">; We aim pile atop the ram</span>
&nbsp;
inicializacion:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %11100100    <span class="co1">;  Palette colors from the darkest to</span>
                            <span class="co1">; Lighter, 11 10 01 00</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; We write this in the background palette register</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rOBP0<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; and sprite palette 0</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; write 0 records scroll in X and Y </span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; positioned so that the visible screen</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; at the beginning (upper left) of the fund.</span>
&nbsp;
    <span class="kw1">call</span>    apaga_LCD       <span class="co1">;  We call the routine that turns off the LCD</span>
&nbsp;
    <span class="co1">; We load the tiles in memory of tiles</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Tiles       <span class="co1">; HL loaded in the direction of our tile</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _VRAM       <span class="co1">; address in the video memory</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="nu0">32</span>           <span class="co1">; b = 32, number of bytes to copy (2 tiles)</span>
&nbsp;
.bucle_carga:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>          <span class="co1">;  A load in the data pointed to by HL</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>         <span class="co1">; y and we put in the address pointed in DE </span>
    <span class="kw1">dec</span>     <span class="kw3">b</span>               <span class="co1">;decrement b, b = b-1</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_bucle_carga <span class="co1">; if b = 0, finished, nothing left to copy</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">; We increased the read direction</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>              <span class="co1">;  We increased the write direction</span>
    <span class="kw1">jr</span>      .bucle_carga    <span class="co1">; we follow</span>
.fin_bucle_carga:
&nbsp;
    <span class="co1">; We clean the screen (fill entire background map), with tile 0</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SCRN0
    <span class="kw1">ld</span>      <span class="kw3">de</span>, <span class="nu0">32</span>*<span class="nu0">32</span>       <span class="co1">;number of tiles on the background map</span>
.bucle_limpieza:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; tile 0 is our empty tile</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">dec</span>     <span class="kw3">de</span>
    <span class="co1">; Now I have to check if it is zero, to see if I have it </span>
    <span class="co1">; finishes copying.  dec ningñun flag does not change, so I can not</span>
    <span class="co1">; check the zero flag directly, but that is zero, dye</span>
    <span class="co1">; They must be zero two, so I can make or including </span>
    <span class="co1">; and if the result is zero, both are zero.</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">d</span>            <span class="co1">; d loaded in to</span>
    <span class="kw1">or</span>      <span class="kw3">e</span>               <span class="co1">; and make a or e</span>
    <span class="kw1">jp</span>      <span class="kw5">z</span>, .fin_bucle_limpieza  <span class="co1">; if d or e is zero, it is zero.  We ended.</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">;  We increased the write direction</span>
    <span class="kw1">jp</span>      .bucle_limpieza
.fin_bucle_limpieza
&nbsp;
    <span class="co1">; Well, we have all the map tiles filled with tile 0, </span>
    <span class="co1">; Now we will create the sprite.</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 30
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">;Y position of the sprite     </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 30
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_X<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; X position of the sprite</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 1
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_NUM<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; number of tile on the table that we will use tiles</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; special attributes, so far nothing.</span>
&nbsp;
    <span class="co1">; configure and activate the display</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJON
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; We prepare animation variables</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 1
    <span class="kw1">ld</span>      <span class="br0">[</span>_MOVX<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_MOVY<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; infinite loop</span>
animacion:
    <span class="co1">; first, we wait for the VBlank, since we can not change</span>
    <span class="co1">; VRAM out of it, or weird things will</span>
.<span class="kw1">wait</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .<span class="kw1">wait</span>
    <span class="co1">; incrementamos las y</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>    <span class="co1">;  And we load the current position of the sprite</span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _MOVY       <span class="co1">; hl in the direction of increasing Y</span>
    <span class="kw1">add</span>     <span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>         <span class="co1">; add</span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SPR0_Y
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>         <span class="co1">; keep</span>
    <span class="co1">; compared to see if they change the direction</span>
    <span class="kw1">cp</span>      <span class="nu0">152</span>             <span class="co1">; so you do not exit the screen (max Y)</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .dec_y
    <span class="kw1">cp</span>      16
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .inc_y       <span class="co1">; the same minimum coordinate Y = 16</span>
    <span class="co1">; do not change</span>
    <span class="kw1">jr</span>      .end_y
.dec_y:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, -<span class="nu0">1</span>           <span class="co1">; now we have to decrease the Y </span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_MOVY<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">jr</span>      .end_y
.inc_y:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">1</span>            <span class="co1">; now we have to increase the Y</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_MOVY<span class="br0">]</span>, <span class="kw3">a</span>
.end_y:
    <span class="co1">; we go with the X, the same but changing the margins </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SPR0_X<span class="br0">]</span>    <span class="co1">; We load the current X position of the sprite</span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _MOVX       <span class="co1">; hl, the incrementing direction X</span>
    <span class="kw1">add</span>     <span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>         <span class="co1">; add
</span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SPR0_X
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>         <span class="co1">; keep</span>
    <span class="co1">; compared to see if they change the direction</span>
    <span class="kw1">cp</span>      <span class="nu0">160</span>             <span class="co1">; so you do not exit the screen (max X)</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .dec_x
    <span class="kw1">cp</span>      <span class="nu0">8</span>               <span class="co1">; the same minimum coord left = 8 </span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .inc_x
    <span class="co1">; do not change</span>
    <span class="kw1">jr</span>      .end_x
.dec_x:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, -<span class="nu0">1</span>           <span class="co1">; now we have to decrease the X </span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_MOVX<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">jr</span>      .end_x
.inc_x:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">1</span>            <span class="co1">; now we have to increase the X </span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_MOVX<span class="br0">]</span>, <span class="kw3">a</span>
.end_x:
    <span class="co1">; a small delay </span>
    <span class="kw1">call</span> retardo
    <span class="co1">; we start </span>
    <span class="kw1">jr</span>      animacion
&nbsp;
<span class="co1">; LCD shutdown routine</span>
apaga_LCD:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
    <span class="kw1">rlca</span>                    <span class="co1">; It sets the high bit of LCDC in the carry flag</span>
    <span class="kw1">ret</span>     <span class="kw5">nc</span>              <span class="co1">; Display is already off, again.</span>
&nbsp;
    <span class="co1">; We VBlank hope to, because we can not turn off the screen</span>
    <span class="co1">; some other time</span>
&nbsp;
.espera_VBlank
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .espera_VBlank
&nbsp;
    <span class="co1">; we are in VBlank, we turn off the LCD</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>       <span class="co1">; in A, the contents of the LCDC </span>
    <span class="kw1">res</span>     7,<span class="kw3">a</span>             <span class="co1">; we zero bit 7 (on the LCD)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>       <span class="co1">; We wrote in the LCDC register content A</span>
&nbsp;
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
&nbsp;
<span class="co1">; delay routine</span>
retardo:
    <span class="kw1">ld</span>      <span class="kw3">de</span>, <span class="nu0">2000</span>        <span class="co1">; number of times to execute the loop</span>
.delay:
    <span class="kw1">dec</span>     <span class="kw3">de</span>              <span class="co1">; decrement</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">d</span>            <span class="co1">; see if zero</span>
    <span class="kw1">or</span>      <span class="kw3">e</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_delay
    <span class="kw1">nop</span>
    <span class="kw1">jr</span>      .delay
.fin_delay:
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Our tiles Facts</span>
Tiles:
    <span class="kw4">DB</span>  $AA, $00, $44, $00, $AA, $00, $11, $00
    <span class="kw4">DB</span>  $AA, $00, $44, $00, $AA, $00, $11, $00
    <span class="kw4">DB</span>  $3E, $3E, $41, $7F, $41, $6B, $41, $7F
    <span class="kw4">DB</span>  $<span class="nu0">41</span>, $<span class="nu0">63</span>, $<span class="nu0">41</span>, $7F, $3E, $3E, $00, $00
EndTiles:</pre>
</dd></dl>

<p>
The result: 
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=bgb00003.png" class="media" title="bgb00003.png"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch.png" class="media" alt=""></a>
</p>

</div>

<h1><a name="hola_joypad" id="hola_joypad">Hello JoyPad</a></h1>
<div class="level1">

<p>
Well, let's create an example for reading the Pad and buttons. If we go to great PanDocs and its section on the pad, (<a href="http://gbdev.gg8.se/wiki/articles/Joypad_Input" class="urlextern" title="http://gbdev.gg8.se/wiki/articles/Joypad_Input" rel="nofollow">http://gbdev.gg8.se/wiki/articles/Joypad_Input</a>), we see that we have a record mapped memory, $ FF00, we will call rP1 ( of Player 1), we can read to know the state of the pad and buttons. Well, I guess to save pins on the CPU of the gameboy, the designers decided to implement a matrix type layout for the buttons on the GameBoy, so the directional pad (4 buttons), and A, B, Select, buttons Start, share the input lines. So how can we know which is pressed ?. For as we see in the PanDocs, there are two bits in this register, allowing us to "activate" or pad and buttons, and then read them. Let's see the log:
</p>
<pre class="code">
  Bit 7 - Sin uso
  Bit 7 - Not used
  Bit 6 - Not used
  Bit 5 - P15 Select buttons (0 = Select)
  Bit 4 - P14 Select the directional pad (0 = Select)
  Bit 3 - P13 Down or Start (0 = Down) (Read Only)
  Bit 2 - P12 Up or Select (0 = Down) (Read Only)
  Bit 1 - P11 Left or B (0 = Down) (Read Only)
  Bit 0 - P10 Right or A (0 = Down) (Read Only)

</pre>

<p>
So how are we going to do to read all the buttons? Well, simple, let's create a routine that will do is:

</p>
<ul>
<li class="level1"><div class="li"> Turn off the pad and buttons</div>
</li>
<li class="level1"><div class="li"> Read the last four bits of the record pad in A (with what we have in the state A directional PAD)</div>
</li>
<li class="level1"><div class="li"> Zero the upper 4 bits of A (only care about the 4 low)</div>
</li>
<li class="level1"><div class="li">  Exchanging the 4 low bits of A by high (low remaining to us free again and the directional pad being remembered on high) </div>
</li>
<li class="level1"><div class="li"> A temporary move to another record (for example B) </div>
</li>
<li class="level1"><div class="li">  Enable and disable buttons PAD </div>
</li>
<li class="level1"><div class="li">  Read the last four bits of the record pad in A (with what we have to the state of the buttons) </div>
</li>
<li class="level1"><div class="li"> Zero the upper 4 bits of A (only care about low)</div>
</li>
<li class="level1"><div class="li"> Make an OR with temporary registration (B), thus, to take the status of all (the pad in the 4 high bits, and buttons on the 4 low) buttons </div>
</li>
<li class="level1"><div class="li"> Get the complement of A, which changes the 0's by 1's and 1's for zeros, so we pressed a few buttons instead of the other way around </div>
</li>
<li class="level1"><div class="li"> To save a variable in memory.</div>
</li>
</ul>

<p>

Then we will check this variable to find out what buttons are pressed (the bits that are to 0) and move the sprite according to the buttons. We will also switch between the two possible palettes sprites when you press A. 
</p>

<p>
One thing to consider is the "bouncing". The electrical contacts of the buttons of each button, can suffer from the effect known as "bouncing" that is, at the microscopic level when you press a button, contact bounce producing small jumps in the signal, so that a small space of time, the signal is not real, and you can read that a button is not pressed, as if it is, or that the button is pressed when you just let go.Modern appliances, usually have circuitry that controls this bouncing, but not the GameBoy. The solution is simple, make a few readings followed, to try to minimize this effect.
</p>

<p>
I've also added code to clear the memory attribute sprites, to put the 40 sprites, all at zero, so the sprites unused, will be off the screen. Perhaps it emulators nothing happens, but in real GameBoy, I've had a couple of sprites with "junk" appeared from the middle of the screen. You never know what can hold the RAM chips on startup (static and so on), so remember, always initialize. 
</p>

<p>
Then let the program:
</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=31" title="Descargar trozo de código fuente" class="mediafile mf_asm">holajoypad.asm</a></dt>
<dd><pre class="code asm"><span class="co1">; Hello joypad</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; For the tutorial(Spanish): </span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span>
&nbsp;
<span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>          <span class="co1">; import file definitions</span>
&nbsp;
<span class="co1">; We define constants to work with our sprite</span>
_SPR0_Y    <span class="kw4"> EQU</span>     _OAMRAM <span class="co1">; sprite Y 0 is the beginning of the sprite mem</span>
_SPR0_X    <span class="kw4"> EQU</span>     _OAMRAM+1
_SPR0_NUM  <span class="kw4"> EQU</span>     _OAMRAM+2
_SPR0_ATT  <span class="kw4"> EQU</span>     _OAMRAM+<span class="nu0">3</span>
&nbsp;
<span class="co1">;variable to save the state of the pad</span>
_PAD       <span class="kw4"> EQU</span>     _RAM <span class="co1">; at the beginning of the internal RAM</span>
&nbsp;
<span class="co1">; The program begins here:</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>      inicio
&nbsp;
<span class="co1">; Head of the ROM (Macro defined in gbhw.inc)</span>
<span class="co1">; defines a rom without mapper, without 32K RAM, the basics</span>
<span class="co1">; (Such as tetris)</span>
    ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE
&nbsp;
<span class="co1">; Here begins are program</span>
inicio:
    <span class="kw1">nop</span>
    <span class="kw1">di</span>                      <span class="co1">; disables interrupts</span>
    <span class="kw1">ld</span>      <span class="kw3">sp</span>, $ffff       <span class="co1">; We aim pile atop the ram</span>
&nbsp;
inicializacion:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %11100100    <span class="co1">; Palette colors from the darkest to</span>
                            <span class="co1">; lighter, 11 10 01 00</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; We write this in the background palette register</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rOBP0<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; and sprite palette 0</span>
&nbsp;
    <span class="co1">; create another palette to the palette 2 sprites, reverse to normal</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00011011
    <span class="kw1">ld</span>      <span class="br0">[</span>rOBP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; write 0 records scroll in X and Y </span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; positioned so that the visible screen</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; at the beginning (upper left) of the fund.</span>
&nbsp;
    <span class="kw1">call</span>    apaga_LCD       <span class="co1">; We call the routine that turns off the LCD</span>
&nbsp;
    <span class="co1">; We load the tiles in memory of tiles</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Tiles       <span class="co1">; HL loaded in the direction of our tile</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _VRAM       <span class="co1">; address in the video memory</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="nu0">32</span>           <span class="co1">; b = 32, number of bytes to copy (2 tiles)</span>
&nbsp;
.bucle_carga:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>          <span class="co1">; load in the data pointed to by HL</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>         <span class="co1">; and we put in the address pointed in DE</span>
    <span class="kw1">dec</span>     <span class="kw3">b</span>               <span class="co1">; decrement b, b = b-1</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_bucle_carga <span class="co1">; if b = 0, finished, nothing left to copy </span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">; We increased the read direction</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>              <span class="co1">; We increased the write direction</span>
    <span class="kw1">jr</span>      .bucle_carga    <span class="co1">; we follow</span>
.fin_bucle_carga:
&nbsp;
    <span class="co1">;  We clean the screen (fill entire background map), with tile 0</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SCRN0
    <span class="kw1">ld</span>      <span class="kw3">de</span>, <span class="nu0">32</span>*<span class="nu0">32</span>       <span class="co1">; number of tiles on the background map</span>
.bucle_limpieza_fondo:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; tile 0 is our empty tile</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">dec</span>     <span class="kw3">de</span>
    <span class="co1">; Now I have to check if it is zero, to see if I have it </span>
    <span class="co1">; finishes copying. dec not modify any flag, so I can not</span>
    <span class="co1">; check the zero flag directly, but that is zero, dye </span>
    <span class="co1">; They must be zero two, so I can make or including </span>
    <span class="co1">; and if the result is zero, both are zero.</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">d</span>            <span class="co1">; d loaded in to</span>
    <span class="kw1">or</span>      <span class="kw3">e</span>               <span class="co1">; and make a or e</span>
    <span class="kw1">jp</span>      <span class="kw5">z</span>, .fin_bucle_limpieza_fondo    <span class="co1">; if d or e is zero, it is zero. </span>
                                            <span class="co1">; Ended.</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">; We increased the write direction</span>
    <span class="kw1">jp</span>      .bucle_limpieza_fondo
.fin_bucle_limpieza_fondo
&nbsp;
    <span class="co1">; Well, we have all the map tiles filled with tile 0</span>
    <span class="co1">; We clean the memory of sprites</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _OAMRAM     <span class="co1">; sprite attribute memory</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, <span class="nu0">40</span>*<span class="nu0">4</span>        <span class="co1">; 40 sprites x 4 bytes each</span>
.bucle_limpieza_sprites
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; we will start fresh, so the sprites</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>         <span class="co1">; unused, will be offscreen</span>
    <span class="kw1">dec</span>     <span class="kw3">de</span>
    <span class="co1">; as in previous loop</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">d</span>            <span class="co1">; d loaded in to</span>
    <span class="kw1">or</span>      <span class="kw3">e</span>               <span class="co1">; and make a or e</span>
    <span class="kw1">jp</span>      <span class="kw5">z</span>, .fin_bucle_limpieza_sprites  <span class="co1">; if d or e is zero, it is zero.</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>              <span class="co1">; We increased the write direction</span>
    <span class="kw1">jp</span>      .bucle_limpieza_sprites
.fin_bucle_limpieza_sprites
&nbsp;
    <span class="co1">; Now we will create the sprite.</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 74
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; Y position of the sprite</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 90
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_X<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; X position of the sprite</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 1
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_NUM<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; number of tile on the table that we will use tiles</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; special attributes, so far nothing.</span>
&nbsp;
    <span class="co1">; configure and activate the display</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJON
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
<span class="co1">; main loop</span>
movimiento:
    <span class="co1">; We read the pad</span>
    <span class="kw1">call</span>    lee_pad
    <span class="co1">; first, we wait for the VBlank, since we can not change</span>
    <span class="co1">; VRAM out of it, or weird things will</span>
.<span class="kw1">wait</span>:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .<span class="kw1">wait</span>
&nbsp;
    <span class="co1">; Now we move the sprite depending on the buttons</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>       <span class="co1">; We charge status pad</span>
    <span class="kw1">and</span>     %00010000       <span class="co1">; right</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, mueve_derecha   <span class="co1">; if the result is not zero, there had 1</span>
                                <span class="co1">; then we call the subroutine</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %00100000       <span class="co1">; left</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, mueve_izquierda
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %01000000       <span class="co1">; above</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, mueve_arriba
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %10000000       <span class="co1">; down</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, mueve_abajo
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %00000001       <span class="co1">; A button</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, cambia_paleta
&nbsp;
    <span class="co1">; a small delay</span>
    <span class="kw1">call</span> retardo
    <span class="co1">; we start</span>
    <span class="kw1">jr</span>      movimiento
&nbsp;
&nbsp;
<span class="co1">; Movement routines</span>
mueve_derecha:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,  <span class="br0">[</span>_SPR0_X<span class="br0">]</span>   <span class="co1">; We get the current position</span>
    <span class="kw1">cp</span>      <span class="nu0">160</span>             <span class="co1">; We are on the corner?</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>               <span class="co1">; if we are in the corner, back</span>
&nbsp;
    <span class="kw1">inc</span>     <span class="kw3">a</span>               <span class="co1">; move</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_X<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; We keep the position</span>
&nbsp;
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
&nbsp;
mueve_izquierda:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,  <span class="br0">[</span>_SPR0_X<span class="br0">]</span>   <span class="co1">; We get the current position</span>
    <span class="kw1">cp</span>      <span class="nu0">8</span>               <span class="co1">; We are on the corner?</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>               <span class="co1">; if we are in the corner, back</span>
&nbsp;
    <span class="kw1">dec</span>     <span class="kw3">a</span>               <span class="co1">; go back</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_X<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; We keep the position</span>
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
mueve_arriba:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,  <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>   <span class="co1">; We get the current position</span>
    <span class="kw1">cp</span>      <span class="nu0">16</span>              <span class="co1">; We are on the corner?</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>               <span class="co1">; if we are in the corner, back</span>
&nbsp;
    <span class="kw1">dec</span>     <span class="kw3">a</span>               <span class="co1">; go back</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; We keep the position</span>
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
mueve_abajo:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,  <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>   <span class="co1">; We get the current positionl</span>
    <span class="kw1">cp</span>      <span class="nu0">152</span>             <span class="co1">; We are on the corner?</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>               <span class="co1">; if we are in the corner, back</span>
&nbsp;
    <span class="kw1">inc</span>     <span class="kw3">a</span>               <span class="co1">; move</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; We keep the position</span>
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
cambia_paleta:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>
    <span class="kw1">and</span>     %00010000       <span class="co1">; in bit 4, is the number of palette</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .paleta0     <span class="co1">; If zero was selected palette 0</span>
&nbsp;
    <span class="co1">; if not, was selected blade 1</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>
    <span class="kw1">res</span>     4, <span class="kw3">a</span>            <span class="co1">; we zero bit 4, selecting the palette 0</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; We keep attributes </span>
&nbsp;
    <span class="kw1">call</span>    retardo         <span class="co1">; the change is very fast, we will wait a bit </span>
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
.paleta0:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>
    set     4, <span class="kw3">a</span>            <span class="co1">; We put one bit 4, selecting blade 1</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; We keep attributes</span>
&nbsp;
    <span class="kw1">call</span>    retardo
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
&nbsp;
<span class="co1">; Routine reading pad</span>
lee_pad:
    <span class="co1">;  we will read the Cruzeta:</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00100000    <span class="co1">; bit 4-0, 5-1 bit (on Cruzeta, no buttons)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; now we read the status of the Cruzeta, to avoid bouncing</span>
    <span class="co1">; We do several readings</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
&nbsp;
    <span class="kw1">and</span>     $0F             <span class="co1">; only care about the bottom 4 bits.</span>
    swap    <span class="kw3">a</span>               <span class="co1">; lower and upper exchange. </span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="kw3">a</span>            <span class="co1">; We keep Cruzeta status in b</span>
&nbsp;
    <span class="co1">; we go for the buttons</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00010000    <span class="co1">; bit 4 to 1, bit 5 to 0 (enabled buttons, not Cruzeta)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; read several times to avoid bouncing</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
&nbsp;
    <span class="co1">; we at A, the state of the buttons</span>
    <span class="kw1">and</span>     $0F             <span class="co1">; only care about the bottom 4 bit</span>
    <span class="kw1">or</span>      <span class="kw3">b</span>               <span class="co1">; or make a to b, to "meter" in Part</span>
                            <span class="co1">; A superior, Cruzeta status.</span>
&nbsp;
    <span class="co1">; we now have at A, the state of all, we complement and</span>
    <span class="co1">; store it in the variable</span>
    cpl
    <span class="kw1">ld</span>      <span class="br0">[</span>_PAD<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; return</span>
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; LCD shutdown routine</span>
apaga_LCD:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
    <span class="kw1">rlca</span>                    <span class="co1">; It sets the high bit of LCDC in the carry flag</span>
    <span class="kw1">ret</span>     <span class="kw5">nc</span>              <span class="co1">; Display is already off, again.</span>
&nbsp;
    <span class="co1">; We VBlank hope to, because we can not turn off the screen</span>
    <span class="co1">; some other time</span>
&nbsp;
.espera_VBlank
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .espera_VBlank
&nbsp;
    <span class="co1">; we are in VBlank, turn off the LCD </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>       <span class="co1">;in A, the contents of the LCDC</span>
    <span class="kw1">res</span>     7,<span class="kw3">a</span>             <span class="co1">; we zero bit 7 (on the LCD)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>       <span class="co1">; We wrote in the LCDC register content A</span>
&nbsp;
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
&nbsp;
<span class="co1">; rdelay routine</span>
retardo:
    <span class="kw1">ld</span>      <span class="kw3">de</span>, <span class="nu0">2000</span>        <span class="co1">; number of times to execute the loop</span>
.delay:
    <span class="kw1">dec</span>     <span class="kw3">de</span>              <span class="co1">; decrement</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">d</span>            <span class="co1">; see if zero</span>
    <span class="kw1">or</span>      <span class="kw3">e</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_delay
    <span class="kw1">nop</span>
    <span class="kw1">jr</span>      .delay
.fin_delay:
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Our tiles Facts</span>
Tiles:
    <span class="kw4">DB</span>  $AA, $00, $44, $00, $AA, $00, $11, $00
    <span class="kw4">DB</span>  $AA, $00, $44, $00, $AA, $00, $11, $00
    <span class="kw4">DB</span>  $3E, $3E, $41, $7F, $41, $6B, $41, $7F
    <span class="kw4">DB</span>  $<span class="nu0">41</span>, $<span class="nu0">63</span>, $<span class="nu0">41</span>, $7F, $3E, $3E, $00, $00
EndTiles:</pre>
</dd></dl>

</div>

<h1><a name="hola_ventana" id="hola_ventana">Hello Window</a></h1>
<div class="level1">

<p>

Now in this example, we will make use of the window, like a typical screens "start" with information in some games. Games like Zelda, use this technique. Simply load the other map tiles (remember that there were two maps, one for $ 9800- $ 9BFF, and another $ 9C00- $ 9FFF), with the tiles you want to show in the window, and say to the window, Use this map to the window prevented from starting the rLCDC. In addition, for this example, I added a lot of things. To start I created a map background with multiple tiles, like a screen of a game, and we can move across the width of the map, using the scroll records. Thus, when the sprite reaches a certain position, we will not let you move more, but we will move the scroll to make it appear that continues to move beyond the screen. Also I will use a 16 × 16 sprite. How?For simple sprites using 4 8 × 8 together, and moving simultaneously when necessary. Also I will use the attributes of the sprites, making them a mirror move depending on whether left or right, so I can use the same tiles for both directions. Another trick I've used is to switch between three sets of sprites for the character, when you are moving. So it seems that your legs move. Num_spr_mario subroutines are responsible, and camina_mario. Besides the sin_pulsaciones routine returns to the quiet character sprite when nothing is pressed. In the code, you can see, I've added eg RellenaMemoria CopiaMemoria and subroutines. As was making multiple copies to fill in memory tiles, maps, clean sprites, etc, because I left them as subroutines, they expect the data in some records, so we can reuse them. I have also left aside the sprites in files, so I can make changes more easily. In the end, you see that use the includes two tags for deliminar data within each file.
</p>

<p>
And nothing, all this together, then: 
</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=32" title="Descargar trozo de código fuente" class="mediafile mf_asm">holaventana.asm</a></dt>
<dd><pre class="code asm"><span class="co1">; Hello Window</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; For the tutorial(Spanish): </span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span>
&nbsp;
<span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>			<span class="co1">; import file definitions</span>
&nbsp;
<span class="co1">; We define constants to work with our sprites </span>
_SPR0_Y		EQU		_OAMRAM	<span class="co1">; sprite Y 0 is the beginning of the sprite mem</span>
_SPR0_X		EQU		_OAMRAM+<span class="nu0">1</span>
_SPR0_NUM	EQU		_OAMRAM+<span class="nu0">2</span>
_SPR0_ATT	EQU		_OAMRAM+<span class="nu0">3</span>
&nbsp;
_SPR1_Y     	EQU     	_OAMRAM+<span class="nu0">4</span>
_SPR1_X     	EQU     	_OAMRAM+<span class="nu0">5</span>
_SPR1_NUM   	EQU     	_OAMRAM+<span class="nu0">6</span>
_SPR1_ATT   	EQU     	_OAMRAM+<span class="nu0">7</span>
&nbsp;
_SPR2_Y     	EQU     	_OAMRAM+<span class="nu0">8</span>
_SPR2_X     	EQU     	_OAMRAM+<span class="nu0">9</span>
_SPR2_NUM   	EQU     	_OAMRAM+<span class="nu0">10</span>
_SPR2_ATT   	EQU     	_OAMRAM+<span class="nu0">11</span>
&nbsp;
_SPR3_Y     	EQU     	_OAMRAM+<span class="nu0">12</span>
_SPR3_X     	EQU     	_OAMRAM+<span class="nu0">13</span>
_SPR3_NUM   	EQU     	_OAMRAM+<span class="nu0">14</span>
_SPR3_ATT   	EQU     	_OAMRAM+<span class="nu0">15</span>
&nbsp;
<span class="co1">; VARIABLES</span>
<span class="co1">; variable to save the state of the pad</span>
_PAD			EQU		_RAM 	<span class="co1">; at the beginning of the internal RAM</span>
<span class="co1">; control variables sprites </span>
_POS_MAR_2		EQU		_RAM+<span class="nu0">1</span>	<span class="co1">; placing the second position where sprites </span>
_SPR_MAR_SUM		EQU		_RAM+<span class="nu0">2</span>	<span class="co1">; I number to add to the sprites to alternate them</span>
&nbsp;
<span class="co1">; The program begins here:</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>  	inicio
&nbsp;
<span class="co1">; Head of the ROM (Macro defined in gbhw.inc)</span>
<span class="co1">; defines a rom without mapper, without 32K RAM, the basics</span>
<span class="co1">; (Such as tetris)</span>
	ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE
&nbsp;
<span class="co1">; Here begins our program</span>
inicio:
	<span class="kw1">nop</span>
	<span class="kw1">di</span>					<span class="co1">; disables interrupts</span>
	<span class="kw1">ld</span>		<span class="kw3">sp</span>, $ffff		<span class="co1">; We aim pile atop the ram</span>
&nbsp;
inicializacion:
&nbsp;
	<span class="co1">; We began variables</span>
	<span class="kw1">ld</span>		<span class="kw3">hl</span>, _POS_MAR_2		<span class="co1">; sprites looking to the right.</span>
	<span class="kw1">ld</span>		<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, -8
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">hl</span>, _SPR_MAR_SUM	<span class="co1">; We start with 0 </span>
	<span class="kw1">ld</span>		<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="nu0">0</span>
&nbsp;
	<span class="co1">; pallets</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, %11100100		<span class="co1">; Palette colors from the darkest to</span>
						<span class="co1">; Lighter, 11 10 01 00</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; We write this in the background palette register </span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rOBP0<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; and sprite palette 0</span>
&nbsp;
	<span class="co1">; create another palette to the palette 2 sprites, Mario </span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, %11010000
	<span class="kw1">ld</span>		<span class="br0">[</span>rOBP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; scroll</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="nu0">0</span>			<span class="co1">; write 0 records scroll in X and Y</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; positioned so that the visible screen</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; at the beginning (upper left) of the fund.</span>
&nbsp;
	<span class="co1">; video</span>
	<span class="kw1">call</span>		apaga_LCD		<span class="co1">; We call the routine that turns off the LCD</span>
&nbsp;
	<span class="co1">; We load the tiles in memory of tiles</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">hl</span>, Tiles		<span class="co1">; HL loaded in the direction of our tile</span>
	<span class="kw1">ld</span>		<span class="kw3">de</span>, _VRAM		<span class="co1">; address in the video memory </span>
	<span class="kw1">ld</span>		<span class="kw3">bc</span>, FinTiles-Tiles	<span class="co1">; number of bytes to copy</span>
&nbsp;
	<span class="kw1">call</span>		CopiaMemoria
&nbsp;
	<span class="co1">; We load the map </span>
	<span class="kw1">ld</span>		<span class="kw3">hl</span>, Mapa
	<span class="kw1">ld</span>		<span class="kw3">de</span>, _SCRN0		<span class="co1">; map 0 </span>
	<span class="kw1">ld</span>		<span class="kw3">bc</span>, 32*32
	<span class="kw1">call</span>		CopiaMemoria
&nbsp;
	<span class="co1">; We load the map to the window </span>
	<span class="kw1">ld</span>		<span class="kw3">hl</span>, Ventana
	<span class="kw1">ld</span>		<span class="kw3">de</span>, _SCRN1		<span class="co1">; Map 1 </span>
	<span class="kw1">ld</span>		<span class="kw3">bc</span>, 32*32
	<span class="kw1">call</span>		CopiaMemoria
&nbsp;
	<span class="co1">; well, we all loaded map tiles</span>
	<span class="co1">; We clean the memory of sprites</span>
	<span class="kw1">ld</span>		<span class="kw3">de</span>, _OAMRAM		<span class="co1">; sprite attribute memory</span>
	<span class="kw1">ld</span>		<span class="kw3">bc</span>, <span class="nu0">40</span>*<span class="nu0">4</span>		<span class="co1">; 40 sprites x 4 bytes each</span>
    	<span class="kw1">ld</span>      	<span class="kw3">l</span>, <span class="nu0">0</span>            	<span class="co1">; we will start fresh, so the sprites</span>
	<span class="kw1">call</span>		RellenaMemoria		<span class="co1">; Unused fall outside screen</span>
&nbsp;
	<span class="co1">; Now we will create sprites. </span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, 136
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR0_Y<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; Y position of the sprite		</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, 80
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR0_X<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; X position of the sprite</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, 0
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR0_NUM<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; number of tile on the table that we will use tiles</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, 16 | 32
	<span class="kw1">ld</span> 		<span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; special attributes, Pallet 1</span>
&nbsp;
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 136+8
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_Y<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">;Y position of the sprite     </span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 80
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_X<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">;X position of the sprite</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 1
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_NUM<span class="br0">]</span>, <span class="kw3">a</span>  	<span class="co1">; number of tile on the table that we will use tiles</span>
   	<span class="kw1">ld</span>     	 	<span class="kw3">a</span>, 16 | 32
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_ATT<span class="br0">]</span>, <span class="kw3">a</span>  	<span class="co1">; special attributes, Pallet 1</span>
&nbsp;
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 136
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_Y<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">; Y position of the sprite </span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_POS_MAR_2<span class="br0">]</span>
	<span class="kw1">add</span>		80
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_X<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">; X position of the sprite</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 2
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_NUM<span class="br0">]</span>, <span class="kw3">a</span>  	<span class="co1">; number of tile on the table that we will use tiles</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 16 | 32
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_ATT<span class="br0">]</span>, <span class="kw3">a</span>  	<span class="co1">; special attributes, Pallet 1</span>
&nbsp;
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 136+8
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_Y<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">; Y position of the sprite </span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>_POS_MAR_2<span class="br0">]</span>
	<span class="kw1">add</span>		<span class="kw3">a</span>, 80
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_X<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">; X position of the sprite</span>
    	<span class="kw1">ld</span>     	 	<span class="kw3">a</span>, 3
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_NUM<span class="br0">]</span>, <span class="kw3">a</span>  	<span class="co1">; number of tile on the table that we will use tiles</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 16 | 32
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_ATT<span class="br0">]</span>, <span class="kw3">a</span>  	<span class="co1">; special attributes, Pallet 1</span>
&nbsp;
&nbsp;
	<span class="co1">; configure and activate the display</span>
	<span class="kw1">ld</span>  		<span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJON|LCDCF_WIN9C00
	<span class="kw1">ld</span>  		<span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
<span class="co1">; main loop</span>
movimiento:
	<span class="co1">; We read the pad</span>
	<span class="kw1">call</span>	lee_pad
	<span class="co1">; first, we wait for the VBlank, since we can not change</span>
	<span class="co1">; VRAM out of it, or weird things will happen</span>
.<span class="kw1">wait</span>:
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    	<span class="kw1">cp</span>      	145
    	<span class="kw1">jr</span>      	<span class="kw5">nz</span>, .<span class="kw1">wait</span>
&nbsp;
	<span class="co1">; Now we move the sprite depending on the buttons</span>
	<span class="kw1">ld</span> 		<span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>		<span class="co1">; We charge status pad</span>
	<span class="kw1">and</span>		%00010000		<span class="co1">; right</span>
	<span class="kw1">call</span>		<span class="kw5">nz</span>, mueve_derecha	<span class="co1">; if the result is not zero, there had 1</span>
						<span class="co1">; then we call the subroutine</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
	<span class="kw1">and</span>    		%00100000		<span class="co1">; left</span>
	<span class="kw1">call</span>		<span class="kw5">nz</span>, mueve_izquierda
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
	<span class="kw1">and</span>		%01000000		<span class="co1">; above</span>
	<span class="co1">;call		nz, mueve_arriba</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
	<span class="kw1">and</span>		%10000000		<span class="co1">; down</span>
	<span class="co1">;call		nz, mueve_abajo</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
	<span class="kw1">and</span>		%00001000		<span class="co1">; START Button</span>
	<span class="kw1">call</span>		<span class="kw5">nz</span>, muestra_ventana
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
	<span class="kw1">and</span>		%11111111
	<span class="kw1">call</span>		<span class="kw5">z</span>, sin_pulsaciones
&nbsp;
	<span class="co1">; ;  a small delay</span>
	<span class="kw1">ld</span>		<span class="kw3">bc</span>, 2000
	<span class="kw1">call</span> 		retardo
	<span class="co1">; we start</span>
	<span class="kw1">jr</span> 		movimiento
&nbsp;
&nbsp;
<span class="co1">; Movement routines</span>
mueve_derecha:
	<span class="kw1">ld</span>		<span class="kw3">a</span>,  <span class="br0">[</span>_SPR0_X<span class="br0">]</span>		<span class="co1">; We get the current position</span>
	<span class="kw1">cp</span>		<span class="nu0">120</span>			<span class="co1">; We are on the corner?</span>
	<span class="kw1">jp</span>		<span class="kw5">nz</span>, .ad			<span class="co1">; if we are not around the corner, move</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>rSCX<span class="br0">]</span>		<span class="co1">; if we are on the edge, we move the scroll</span>
	<span class="kw1">inc</span>		<span class="kw3">a</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; modificamos los sprites</span>
	<span class="kw1">call</span>		num_spr_mario
	<span class="kw1">call</span>		camina_mario
&nbsp;
	<span class="kw1">ret</span>
.ad:
	<span class="co1">; the second sprites must be behind the first </span>
	<span class="kw1">push</span>	<span class="kw3">af</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, -8
	<span class="kw1">ld</span>		<span class="br0">[</span>_POS_MAR_2<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">pop</span>		<span class="kw3">af</span>
	<span class="co1">; motion</span>
	<span class="kw1">inc</span>		<span class="kw3">a</span>			<span class="co1">; move</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR0_X<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; We keep the position</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR1_X<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">hl</span>, _POS_MAR_2		<span class="co1">; The first shift</span>
	<span class="kw1">add</span>		<span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>			<span class="co1">; add</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR2_X<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; keep</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR3_X<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="co1">; right, therefore sprites must be reflected horizontally </span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>
	set		5, <span class="kw3">a</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_ATT<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_ATT<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_ATT<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; sprites modify the</span>
	<span class="kw1">call</span>		num_spr_mario
	<span class="kw1">call</span>		camina_mario
&nbsp;
	<span class="kw1">ret</span>					<span class="co1">; return</span>
&nbsp;
mueve_izquierda:
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>,  <span class="br0">[</span>_SPR0_X<span class="br0">]</span>   	<span class="co1">; We get the current position</span>
    	<span class="kw1">cp</span>      	<span class="nu0">16</span>              	<span class="co1">; We are on the corner?</span>
    	<span class="kw1">jp</span>     		<span class="kw5">nz</span>, .ai         	<span class="co1">; if we are not around the corner, move</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>rSCX<span class="br0">]</span>		<span class="co1">; if we are, scroll</span>
	<span class="kw1">dec</span>		<span class="kw3">a</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; mmodify the sprites </span>
	<span class="kw1">call</span>		num_spr_mario
	<span class="kw1">call</span>		camina_mario
&nbsp;
	<span class="kw1">ret</span>
&nbsp;
.ai:
	<span class="co1">; the second sprites must be before the first </span>
	<span class="kw1">push</span>		<span class="kw3">af</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, 8
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_POS_MAR_2<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">pop</span>		<span class="kw3">af</span>
	<span class="co1">; motion</span>
    	<span class="kw1">dec</span>     	<span class="kw3">a</span>               	<span class="co1">; go back</span>
    	<span class="kw1">ld</span>     		<span class="br0">[</span>_SPR0_X<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">;  We keep the position</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_X<span class="br0">]</span>, <span class="kw3">a</span> 	
&nbsp;
    	<span class="kw1">ld</span>      	<span class="kw3">hl</span>, _POS_MAR_2    	<span class="co1">; the first shift</span>
    	<span class="kw1">add</span>     	<span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>         	<span class="co1">; add</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_X<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">; keep</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_X<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; left, therefore, sprite must be reflected horizontally </span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>
    	<span class="kw1">res</span>     	5, <span class="kw3">a</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>, <span class="kw3">a</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_ATT<span class="br0">]</span>, <span class="kw3">a</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_ATT<span class="br0">]</span>, <span class="kw3">a</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_ATT<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; modify the sprites </span>
	<span class="kw1">call</span>		num_spr_mario
	<span class="kw1">call</span>		camina_mario
&nbsp;
    	<span class="kw1">ret</span>                     		<span class="co1">; return</span>
&nbsp;
&nbsp;
mueve_arriba:
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>,  <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>   	<span class="co1">; We get the current position</span>
    	<span class="kw1">cp</span>      	<span class="nu0">16</span>              	<span class="co1">; We are on the corner?</span>
    	<span class="kw1">ret</span>     	<span class="kw5">z</span>               	<span class="co1">; if we are in the corner, back</span>
&nbsp;
    	<span class="kw1">dec</span>     	<span class="kw3">a</span>               	<span class="co1">; go back</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR0_Y<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">; We keep the position</span>
&nbsp;
    	<span class="kw1">ret</span> 
&nbsp;
mueve_abajo:
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>,  <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>   	<span class="co1">; We get the current position</span>
    	<span class="kw1">cp</span>      	<span class="nu0">152</span>             	<span class="co1">; We are on the corner?</span>
    	<span class="kw1">ret</span>     	<span class="kw5">z</span>               	<span class="co1">; if we are in the corner, back</span>
&nbsp;
    	<span class="kw1">inc</span>     	<span class="kw3">a</span>               	<span class="co1">; move</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR0_Y<span class="br0">]</span>, <span class="kw3">a</span>    	<span class="co1">; We keep the position</span>
&nbsp;
    	<span class="kw1">ret</span> 
&nbsp;
muestra_ventana:
	<span class="kw1">ld</span>		<span class="kw3">a</span>, 8
	<span class="kw1">ld</span>		<span class="br0">[</span>rWX<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, 144
	<span class="kw1">ld</span>		<span class="br0">[</span>rWY<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; Activate and deactivate the window sprites</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>rLCDC<span class="br0">]</span>
	<span class="kw1">or</span>		LCDCF_WINON
	<span class="kw1">res</span>		1, <span class="kw3">a</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; animation</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, 144
.anim_most_vent:
	<span class="kw1">push</span>		<span class="kw3">af</span>
	<span class="kw1">ld</span>		<span class="kw3">bc</span>, 1000
	<span class="kw1">call</span>		retardo
	<span class="kw1">pop</span>		<span class="kw3">af</span>
	<span class="kw1">dec</span>		<span class="kw3">a</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>rWY<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">jr</span>		<span class="kw5">nz</span>, .anim_most_vent
&nbsp;
	<span class="co1">; We hope to select pressed to exit</span>
.espera_salir:
	<span class="kw1">call</span>		lee_pad
	<span class="kw1">and</span>     	%00001000       		<span class="co1">; START button </span>
	<span class="kw1">jr</span>		<span class="kw5">z</span>, .espera_salir<span class="co1">;	</span>
&nbsp;
&nbsp;
.anim_ocul_vent:
    	<span class="kw1">push</span>    	<span class="kw3">af</span>
    	<span class="kw1">ld</span>      	<span class="kw3">bc</span>, 1000
    	<span class="kw1">call</span>    	retardo
    	<span class="kw1">pop</span>     	<span class="kw3">af</span>
    	<span class="kw1">inc</span>     	<span class="kw3">a</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>rWY<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">cp</span>		144
    	<span class="kw1">jr</span>     		<span class="kw5">nz</span>, .anim_ocul_vent
&nbsp;
	<span class="co1">; Deactivate and activate the window sprites </span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rLCDC<span class="br0">]</span>
    	<span class="kw1">res</span>		5, <span class="kw3">a</span>
	<span class="kw1">or</span>		LCDCF_OBJON
    	<span class="kw1">ld</span>      	<span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="kw1">ret</span>						<span class="co1">; volvemos</span>
&nbsp;
&nbsp;
<span class="co1">; if nothing is pressed, you come here to modify sprite by mario</span>
<span class="co1">; static</span>
sin_pulsaciones:
	<span class="kw1">ld</span>      	<span class="kw3">hl</span>, _SPR_MAR_SUM<span class="co1">; We start with 0 </span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, 0
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, 0
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR0_NUM<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">inc</span>		<span class="kw3">a</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_NUM<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">inc</span>		<span class="kw3">a</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_NUM<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">inc</span>		<span class="kw3">a</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_NUM<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">ret</span>
&nbsp;
<span class="co1">; modify the variable to change mario sprites walking</span>
num_spr_mario:
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_SPR_MAR_SUM<span class="br0">]</span>
	<span class="kw1">add</span>		<span class="nu0">4</span>				<span class="co1">; add 4</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>_SPR_MAR_SUM<span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; we keep</span>
	<span class="kw1">cp</span>		<span class="nu0">12</span>				<span class="co1">; lower than 12? </span>
	<span class="kw1">ret</span>		<span class="kw5">nz</span>				<span class="co1">; return</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="nu0">4</span>				<span class="co1">; 12? then back to 4</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR_MAR_SUM<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">ret</span>
&nbsp;
camina_mario:
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>_SPR_MAR_SUM<span class="br0">]</span>
	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR0_NUM<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="kw1">inc</span>     	<span class="kw3">a</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR1_NUM<span class="br0">]</span>, <span class="kw3">a</span>
    	<span class="kw1">inc</span>    		<span class="kw3">a</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR2_NUM<span class="br0">]</span>, <span class="kw3">a</span>
    	<span class="kw1">inc</span>     	<span class="kw3">a</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>_SPR3_NUM<span class="br0">]</span>, <span class="kw3">a</span>
    	<span class="kw1">ret</span>
&nbsp;
&nbsp;
<span class="co1">; Routine reading pad</span>
lee_pad:
	<span class="co1">; we will read the Cruzeta:</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, %00100000	<span class="co1">; bit 4-0, 5-1 bit (on Cruzeta, no buttons)</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; now we read the status of the Cruzeta, to avoid bouncing</span>
	<span class="co1">; We do several readings</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
&nbsp;
	<span class="kw1">and</span>		$0F			<span class="co1">; only care about the bottom 4 bits.</span>
	swap		<span class="kw3">a</span>			<span class="co1">; lower and upper exchange. </span>
	<span class="kw1">ld</span>		<span class="kw3">b</span>, <span class="kw3">a</span>			<span class="co1">; We keep Cruzeta status in b</span>
&nbsp;
	<span class="co1">; we go for the buttons</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, %00010000    	<span class="co1">; bit 4 to 1, bit 5 to 0 (enabled buttons, not Cruzeta)</span>
    	<span class="kw1">ld</span>      	<span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
	<span class="co1">; We read several times to avoid bouncing</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    	<span class="kw1">ld</span>      	<span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
&nbsp;
	<span class="co1">; we at A, the state of the buttons</span>
    	<span class="kw1">and</span>     	$0F             	<span class="co1">; only care about the bottom 4 bits.</span>
	<span class="kw1">or</span>		<span class="kw3">b</span>			<span class="co1">; or make a to b, to "meter" in Part</span>
						<span class="co1">; A superior, Cruzeta status.</span>
&nbsp;
	<span class="co1">; we now have at A, the state of all, we complement and</span>
	<span class="co1">; store it in the variable</span>
	cpl
	<span class="kw1">ld</span> 		<span class="br0">[</span>_PAD<span class="br0">]</span>, <span class="kw3">a</span>
	<span class="co1">; volvemos</span>
	<span class="kw1">ret</span>
&nbsp;
<span class="co1">; LCD shutdown routine</span>
apaga_LCD:
	<span class="kw1">ld</span>		<span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
	<span class="kw1">rlca</span>	                	<span class="co1">; It sets the high bit of LCDC in the carry flag</span>
	<span class="kw1">ret</span>		<span class="kw5">nc</span>              <span class="co1">;  Display is already off, again.</span>
&nbsp;
	<span class="co1">; We VBlank hope to, because we can not turn off the screen</span>
	<span class="co1">; some other time</span>
&nbsp;
.espera_VBlank
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
	<span class="kw1">cp</span>		145
	<span class="kw1">jr</span>		<span class="kw5">nz</span>, .espera_VBlank
&nbsp;
	<span class="co1">; we are in VBlank, we turn off the LCD</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>		<span class="co1">; in A, the contents of the LCDC</span>
	<span class="kw1">res</span>		7,<span class="kw3">a</span>			<span class="co1">; we zero bit 7 (on the LCD)</span>
	<span class="kw1">ld</span>		<span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>		<span class="co1">; eWe wrote in the LCDC register content A</span>
&nbsp;
	<span class="kw1">ret</span>					<span class="co1">; return</span>
&nbsp;
<span class="co1">; delay routine</span>
<span class="co1">; parameters</span>
<span class="co1">; bc - number of iterations</span>
retardo:
.delay:
	<span class="kw1">dec</span>		<span class="kw3">bc</span>			<span class="co1">; decrement</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="kw3">b</span>			<span class="co1">; see if zero</span>
	<span class="kw1">or</span>		<span class="kw3">c</span>
	<span class="kw1">jr</span>		<span class="kw5">z</span>, .fin_delay
	<span class="kw1">nop</span>
	<span class="kw1">jr</span>		.delay
.fin_delay:
	<span class="kw1">ret</span>
&nbsp;
<span class="co1">; memory copy routine</span>
<span class="co1">; copy a number of bytes from one direction to another</span>
<span class="co1">; expects the parameters:</span>
<span class="co1">; hl - copying data address</span>
<span class="co1">; of - destination address</span>
<span class="co1">; bc - number of data to be copied</span>
<span class="co1">; destroys the contents of A</span>
CopiaMemoria:
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>		<span class="co1">; To load the data in</span>
	<span class="kw1">ld</span>		<span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>		<span class="co1">; copy the data to the destination</span>
	<span class="kw1">dec</span>		<span class="kw3">bc</span>		<span class="co1">; least one copy</span>
	<span class="co1">; We check if bc is zero</span>
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="kw3">c</span>
	<span class="kw1">or</span>		<span class="kw3">b</span>
	<span class="kw1">ret</span>		<span class="kw5">z</span>		<span class="co1">; If zero, we return</span>
	<span class="co1">; if not, we still</span>
	<span class="kw1">inc</span>		<span class="kw3">hl</span>
	<span class="kw1">inc</span>		<span class="kw3">de</span>
	<span class="kw1">jr</span>		CopiaMemoria
&nbsp;
&nbsp;
<span class="co1">; Fill routine memory</span>
<span class="co1">; filled a number of bytes of memory with a data</span>
<span class="co1">; expects the parameters:</span>
<span class="co1">; of - destination address</span>
<span class="co1">; bc - amount of data to fill</span>
<span class="co1">; l - data to fill</span>
RellenaMemoria:
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="kw3">l</span>
	<span class="kw1">ld</span>		<span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>			<span class="co1">; ;  puts the data in the destination</span>
	<span class="kw1">dec</span>		<span class="kw3">bc</span>			<span class="co1">; least one fill</span>
&nbsp;
	<span class="kw1">ld</span>		<span class="kw3">a</span>, <span class="kw3">c</span>		
	<span class="kw1">or</span>		<span class="kw3">b</span>			<span class="co1">; We check if bc is zero</span>
	<span class="kw1">ret</span>		<span class="kw5">z</span>			<span class="co1">;If zero return</span>
	<span class="kw1">inc</span>		<span class="kw3">de</span>			<span class="co1">; if not, we still</span>
	<span class="kw1">jr</span>		RellenaMemoria
&nbsp;
&nbsp;
Tiles:
<span class="kw4">INCLUDE</span> <span class="st0">"mario_sprites.z80"</span>
FinTiles:
&nbsp;
Mapa:
<span class="kw4">INCLUDE</span> <span class="st0">"mapa_mario.z80"</span>
FinMapa:
&nbsp;
Ventana:
<span class="kw4">INCLUDE</span>	<span class="st0">"ventana.z80"</span>
FinVentana:</pre>
</dd></dl>

<p>
And data,
</p>

<p>
mario_sprites.z80:

</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=33" title="Descargar trozo de código fuente" class="mediafile mf_z80">mario_sprites.z80</a></dt>
<dd><pre class="code asm"><span class="kw4">DB</span> $00,$00,$0F,$0F,$<span class="re1">1B</span>,$14,$7F,$7F
<span class="kw4">DB</span> $<span class="re1">1B</span>,$14,$<span class="re1">1B</span>,$1E,$31,$2F,$3F,$3F
<span class="kw4">DB</span> $10,$1F,$1F,$1F,$3F,$2A,$1F,$15
<span class="kw4">DB</span> $1F,$1F,$07,$07,$09,$0F,$0F,$0F
<span class="kw4">DB</span> $00,$00,$00,$00,$E0,$E0,$F0,$10
<span class="kw4">DB</span> $F0,$F0,$30,$F0,$68,$F8,$88,$F8
<span class="kw4">DB</span> $70,$F0,$F8,$C8,$F8,$68,$B8,$D8
<span class="kw4">DB</span> $98,$F8,$F0,$F0,$10,$F0,$F0,$F0
<span class="kw4">DB</span> $00,$00,$0F,$0F,$<span class="re1">1B</span>,$14,$7F,$7F
<span class="kw4">DB</span> $<span class="re1">1B</span>,$14,$<span class="re1">1B</span>,$1E,$31,$2F,$3F,$3F
<span class="kw4">DB</span> $10,$1F,$0F,$0F,$1E,$<span class="re1">1B</span>,$1E,$17
<span class="kw4">DB</span> $1F,$1F,$0F,$0F,$11,$1F,$1F,$1F
<span class="kw4">DB</span> $00,$00,$00,$00,$E0,$E0,$F0,$10
<span class="kw4">DB</span> $F0,$F0,$30,$F0,$68,$F8,$88,$F8
<span class="kw4">DB</span> $70,$F0,$F0,$90,$F8,$48,$74,$FC
<span class="kw4">DB</span> $F4,$FC,$F4,$FC,$0C,$0C,$00,$00
<span class="kw4">DB</span> $00,$00,$0F,$0F,$<span class="re1">1B</span>,$14,$7F,$7F
<span class="kw4">DB</span> $<span class="re1">1B</span>,$14,$<span class="re1">1B</span>,$1E,$31,$2F,$3F,$3F
<span class="kw4">DB</span> $10,$1F,$6F,$6F,$5F,$7A,$5F,$75
<span class="kw4">DB</span> $5F,$7F,$7F,$7F,$00,$00,$00,$00
<span class="kw4">DB</span> $00,$00,$00,$00,$E0,$E0,$F0,$10
<span class="kw4">DB</span> $F0,$F0,$30,$F0,$68,$F8,$88,$F8
<span class="kw4">DB</span> $70,$F0,$F8,$C8,$F8,$68,$B8,$D8
<span class="kw4">DB</span> $98,$F8,$E8,$F8,$90,$F0,$E0,$E0
<span class="kw4">DB</span> $00,$00,$00,$00,$00,$00,$00,$00
<span class="kw4">DB</span> $00,$00,$00,$00,$00,$00,$00,$00
<span class="kw4">DB</span> $FF,$00,$FF,$00,$FF,$00,$FF,$00
<span class="kw4">DB</span> $FF,$00,$FF,$00,$FF,$00,$FF,$00
<span class="kw4">DB</span> $FF,$FF,$FF,$00,$FF,$88,$FF,$00
<span class="kw4">DB</span> $FF,$20,$FF,$02,$FF,$80,$FF,$22
<span class="kw4">DB</span> $FF,$00,$C3,$3C,$81,$7E,$B9,$46
<span class="kw4">DB</span> $81,$7E,$81,$7E,$9D,$62,$81,$7E
<span class="kw4">DB</span> $FF,$00,$FE,$01,$F8,$07,$F0,$0F
<span class="kw4">DB</span> $E0,$1F,$C0,$3F,$80,$7F,$00,$FF
<span class="kw4">DB</span> $FF,$00,$00,$FF,$00,$FF,$00,$FF
<span class="kw4">DB</span> $00,$FF,$00,$FF,$00,$FF,$00,$FF
<span class="kw4">DB</span> $FF,$00,$1F,$E0,$0F,$F0,$07,$F8
<span class="kw4">DB</span> $03,$FC,$01,$FE,$01,$FE,$01,$FE
<span class="kw4">DB</span> $F8,$00,$97,$00,$6E,$00,$7D,$00
<span class="kw4">DB</span> $7F,$00,$7F,$00,$BB,$00,$C4,$00
<span class="kw4">DB</span> $33,$00,$CD,$00,$FE,$00,$FE,$00
<span class="kw4">DB</span> $FA,$00,$F6,$00,$FD,$00,$03,$00
<span class="kw4">DB</span> $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
<span class="kw4">DB</span> $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
<span class="kw4">DB</span> $FF,$FF,$FF,$FF,$FF,$FF,$E0,$E0
<span class="kw4">DB</span> $EF,$EF,$EF,$EF,$EF,$EF,$EF,$EF
<span class="kw4">DB</span> $FF,$FF,$FF,$FF,$FF,$FF,$00,$00
<span class="kw4">DB</span> $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
<span class="kw4">DB</span> $FF,$FF,$FF,$FF,$FF,$FF,$07,$07
<span class="kw4">DB</span> $F7,$F7,$F7,$F7,$F7,$F7,$F7,$F7
<span class="kw4">DB</span> $F7,$F7,$F7,$F7,$F7,$F7,$F7,$F7
<span class="kw4">DB</span> $F7,$F7,$F7,$F7,$F7,$F7,$F7,$F7
<span class="kw4">DB</span> $F7,$F7,$F7,$F7,$F7,$F7,$F7,$F7
<span class="kw4">DB</span> $07,$07,$FF,$FF,$FF,$FF,$FF,$FF
<span class="kw4">DB</span> $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF
<span class="kw4">DB</span> $00,$00,$FF,$FF,$FF,$FF,$FF,$FF
<span class="kw4">DB</span> $EF,$EF,$EF,$EF,$EF,$EF,$EF,$EF
<span class="kw4">DB</span> $E0,$E0,$FF,$FF,$FF,$FF,$FF,$FF
<span class="kw4">DB</span> $EF,$EF,$EF,$EF,$EF,$EF,$EF,$EF
<span class="kw4">DB</span> $EF,$EF,$EF,$EF,$EF,$EF,$EF,$EF
<span class="kw4">DB</span> $FF,$FF,$BD,$BD,$BD,$BD,$DB,$DB
<span class="kw4">DB</span> $DB,$DB,$E7,$E7,$E7,$E7,$FF,$FF
<span class="kw4">DB</span> $FF,$FF,$83,$83,$BF,$BF,$8F,$8F
<span class="kw4">DB</span> $BF,$BF,$BF,$BF,$83,$83,$FF,$FF
<span class="kw4">DB</span> $FF,$FF,$9D,$9D,$AD,$AD,$AD,$AD
<span class="kw4">DB</span> $B5,$B5,$B5,$B5,$B9,$B9,$FF,$FF
<span class="kw4">DB</span> $FF,$FF,$83,$83,$EF,$EF,$EF,$EF
<span class="kw4">DB</span> $EF,$EF,$EF,$EF,$EF,$EF,$FF,$FF
<span class="kw4">DB</span> $FF,$FF,$E7,$E7,$DB,$DB,$DB,$DB
<span class="kw4">DB</span> $<span class="nu0">81</span>,$<span class="nu0">81</span>,$BD,$BD,$BD,$BD,$FF,$FF</pre>
</dd></dl>

<p>
mapa_mario.z80

</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=34" title="Descargar trozo de código fuente" class="mediafile mf_z80">mapa_mario.z80</a></dt>
<dd><pre class="code asm"><span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$13,$14,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$13,$14,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$13,$14,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$13,$14
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$13,$14,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0F,$0D,$10,$11
<span class="kw4">DB</span> $11,$12,$0D,$0F,$0D,$0D,$0D,$10,$11,$12
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0F,$0D,$0F,$0D,$0D,$10
<span class="kw4">DB</span> $11,$11,$12,$0D,$0E,$0E,$0E,$0E,$0E,$0E
<span class="kw4">DB</span> $0E,$0E,$0E,$0E,$0E,$0E,$0E,$0E,$0E,$0E
<span class="kw4">DB</span> $0E,$0E,$0E,$0E,$0E,$0E,$0E,$0E,$0E,$0E
<span class="kw4">DB</span> $0E,$0E,$0E,$0E,$0E,$0E,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D,$0D
<span class="kw4">DB</span> $0D,$0D,$0D,$0D</pre>
</dd></dl>

<p>
and ventana.z80

</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=35" title="Descargar trozo de código fuente" class="mediafile mf_z80">ventana.z80</a></dt>
<dd><pre class="code asm"><span class="kw4">DB</span> $16,$17,$17,$17,$17,$17,$17,$17,$17,$17
<span class="kw4">DB</span> $17,$17,$17,$17,$17,$17,$17,$17,$17,$18
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$1D,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$19,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$1D,$15,$16,$17,$17,$17
<span class="kw4">DB</span> $17,$17,$17,$17,$17,$17,$17,$17,$17,$17
<span class="kw4">DB</span> $17,$18,$15,$19,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$1D,$15,$1D,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$19,$15,$19,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$1D,$15
<span class="kw4">DB</span> $1D,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$19,$15,$19,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $1D,$15,$1D,$15,$15,$15,$1E,$1F,$20,$21
<span class="kw4">DB</span> $22,$20,$22,$15,$15,$15,$15,$19,$15,$19
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$1D,$15,$1D,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$19
<span class="kw4">DB</span> $15,$19,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$1D,$15,$1D,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$19,$15,$19,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$1D,$15,$1D,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$19,$15,$19,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$1D,$15
<span class="kw4">DB</span> $1D,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$19,$15,$19,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $1D,$15,$1D,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$19,$15,$19
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$1D,$15,$1D,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$19
<span class="kw4">DB</span> $15,$19,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$1D,$15,$1D,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$19,$15,$19,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$1D,$15,$1D,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$19,$15,$19,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$1D,$15
<span class="kw4">DB</span> $1D,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$19,$15,$19,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $1D,$15,$1C,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>
<span class="kw4">DB</span> $<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$1A,$15,$19
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$1D,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$19,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$1C,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>
<span class="kw4">DB</span> $<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>
<span class="kw4">DB</span> $<span class="re1">1B</span>,$<span class="re1">1B</span>,$<span class="re1">1B</span>,$1A,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $15,$15,$15,$15,$15,$15,$15,$15,$15,$15
<span class="kw4">DB</span> $<span class="nu0">15</span>,$<span class="nu0">15</span>,$<span class="nu0">15</span>,$<span class="nu0">15</span></pre>
</dd></dl>

<p>
The Result:
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=hola-ventana.gb" class="media mediafile mf_gb" title="hola-ventana.gb">hola-ventana.gb</a>
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=bgb00004.png" class="media" title="bgb00004.png"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch_007.png" class="media" alt=""></a> <a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=bgb00005.png" class="media" title="bgb00005.png"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch_005.png" class="media" alt=""></a>
</p>

<p>
To generate graphs of this example. I used the GBTD (Gameboy Tile Designer) and GBMB (Gameboy Map Builder), two great tools that allow us to design tiles and maps visually and then generate the data ready for import into our asm programs RGBDS, C GBDK, etc. Wine also function perfectly, for if you want to use from Gnu/Linux (I myself use so). You can download them from:
</p>

<p>
<a href="http://www.devrs.com/gb/hmgd/gbtd.html" class="urlextern" title="http://www.devrs.com/gb/hmgd/gbtd.html" rel="nofollow">http://www.devrs.com/gb/hmgd/gbtd.html</a>
</p>

<p>
<a href="http://www.devrs.com/gb/hmgd/gbmb.html" class="urlextern" title="http://www.devrs.com/gb/hmgd/gbmb.html" rel="nofollow">http://www.devrs.com/gb/hmgd/gbmb.html</a>
</p>

<p>
The GBTD, is very simple to use, selecting tiles going right, and going by drawing on the grid, with some typical tools such as brush, bucket fill, etc, and some not so typical as displacements, etc. Also you can select more grnades modes (eg 16 × 16), who then put it back in 8 × 8 mode, you will see how the tiles are aligned in memory for use. Once your game designed tiles, which grabais, and you give it to "Export To" in the menu "File". There is simple, poneis a filename, type "RGBDS Assembly File", a label name (Label), and a section, and From and To poneis ranges sprites to export, if ye have drawn 10 sprites, poneis as 0 through 9, and activais the checkbox "Export Tiles as one unit". You give it to export, and you have your file .Z80 with Data Pointsa of tiles. I usually clean the entire file and just let the DB with the data, since the ground cover in my own labels and others, and sometimes the definitions of banks and extras that add GBTD do nothing but hinder.
</p>

<p>
Then GBMB, it is also very easy to use. The first to open is going to "Map Properties" from the "File" menu and select there the height and width of the map, for these examples, I always use 32 × 32. The issue is that although it could create a map of eg 20 × 18 for the visible part of the screen when loading it into memory, would have to go by the "jumps", I mean, have to complete 20 bytes memory map, then skip 12 (for 32 complete fill another 20, skip 12, etc. This is not difficult, but when the demos do not need to save memory, and so can use subroutines that have already defined. Then you need to select a file from tiles created with GBTD. You give it to Browse and seleccionais which you have created. You give to "OK" and now you will have your editable map and on the right the list of tiles that you have created. Nothing It is now a matter of going creating the map, filling it with tiles that you have available. Once tengais map ready, go to "Export To" menu "File". As before, seleccionais one nommbre file, type "RGBDS Assembly File ", a tag name, a section (eg 0) and then going to the second tab of" Location Format ". We define as there is stored in the map memory. First on the big picture, the first property seleccionais (out with 1), and seleccionais "[Tile Number], and poneis of 8 bits. Then right, seleccionais, "Map Layout", "Rows", "Plane count": "1 plane, 8 bits" and the rest as is, "Tiles are continues" and Offset 0. You give and you have to export and data ready. And useful file is best to clean and leave only the DB's relevant. 
</p>

</div>

<h1><a name="hola_timer" id="hola_timer">Hello Timer</a></h1>
<div class="level1">

<p>
For this example, we will use the internal timer of the GameBoy, that will help us track time accurately. Besides making use of interruptions and not have to worry about bringing us over, we'll let each time a timer interrupt occurs, a subroutine worry to control time. 
</p>

<p>
The timer has 3 records. rTAC, rTMA and rTIMA. 
</p>

<p>
rTAC is the timer control register allows us to switch it off, and adjust the operating frequency. Bit 2 of this register enables or disables the timer (1 = enabled) and bits 0 and 1, allow you to adjust the frequency according to the following table: 

</p>
<pre class="code">    00:   4096 Hz    (~4194 Hz SGB)
    01: 262144 Hz  (~268400 Hz SGB)
    10:  65536 Hz   (~67110 Hz SGB)
    11:  16384 Hz   (~16780 Hz SGB)
</pre>

<p>
We will use the frequency of 4096Hz, which have the timer is activated every 1/4096 = 0.0002414 seconds. 
</p>

<p>
Each time the timer is activated, increases rTIMA content registration unit. rTIMA is an 8-bit register, so you can count from 0 to 255. When the registration rTIMA overflows (goes from 255 to 0 again), a timer interrupt is generated, if enabled, the CPU will pass control the program to the subroutine timer interrupt handling in the $0050 address.
</p>

<p>
 The third record is rTMA, and is the initial value that is loaded into rTIMA after an overflow, so when rTIMA reaches 255, the overflow generates the interrupt, and then start counting again from the value contained in rTMA, This allows us to adjust how often the most easily interrupt is generated. 
</p>

<p>
So, for this program, a stopwatch, ideally 1 to have in one second. So if we have the frequency is 4096Hz, we know rTIMA increases every 1/4096 = 0.0002414 seconds. Now if we start value rTIMA 51, we have, (1/4096) * (255-51) = (1/4096) * 204 = 0.049 s. Then we know that an interrupt is generated each about 0.05 seconds. If now in the interrupt routine, you do count the times I called, and wait until the call 20 times, we have 0.05 * 20 = 1 second. 
</p>

<p>
In addition to this program, we will use other interruption, disruption of VBlank, which is generated whenever the LCD into the vertical interval period. We call from there, to the drawing routine, always we are sure that the drawing will occur while we are in VBlank :-) <img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/icon_smile.gif" class="middle" alt=":-)">
</p>

<p>
I leave you with the code, you can start or stop the stopwatch with the A button, and reset to zero with B:

</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=37" title="Descargar trozo de código fuente" class="mediafile mf_asm">holatimer.asm</a></dt>
<dd><pre class="code asm"><span class="co1">; Hello Timer</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; For the tutorial(Spanish): </span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span>
&nbsp;
<span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>          <span class="co1">; import file definitions</span>
&nbsp;
<span class="co1">; Variables</span>
_CONTROL_TIEMPO    <span class="kw4"> EQU</span>     _RAM    <span class="co1">;controls milliseconds</span>
_ACTIVADO          <span class="kw4"> EQU</span>     _RAM+<span class="nu0">1</span>  <span class="co1">; Stopwatch activated or not</span>
_SEGUNDOS          <span class="kw4"> EQU</span>     _RAM+2
_MINUTOS           <span class="kw4"> EQU</span>     _RAM+3
_HORAS             <span class="kw4"> EQU</span>     _RAM+4
_PAD               <span class="kw4"> EQU</span>     _RAM+<span class="nu0">5</span>
&nbsp;
<span class="co1">; Constants</span>
_POS_CRONOM        <span class="kw4"> EQU</span>     _SCRN0+<span class="nu0">32</span>*<span class="nu0">4</span>+<span class="nu0">6</span>   <span class="co1">; screen position</span>
&nbsp;
<span class="co1">; VBlank interruption</span>
SECTION <span class="st0">"Vblank"</span>,HOME<span class="br0">[</span>$0040<span class="br0">]</span>
    <span class="kw1">call</span> DibujaCronometro
    <span class="kw1">reti</span>
&nbsp;
<span class="co1">;  timer overflow interrupt</span>
SECTION <span class="st0">"Timer_Overflow"</span>,HOME<span class="br0">[</span>$0050<span class="br0">]</span>
    <span class="co1">;  when there is an interruption of the timer, we call this subroutine</span>
    <span class="kw1">call</span>    ControlTimer
    <span class="kw1">reti</span>
&nbsp;
<span class="co1">; The program begins here:</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>      inicio
&nbsp;
<span class="co1">;  Head of the ROM (Macro defined in gbhw.inc)</span>
<span class="co1">; defines a rom without mapper, without 32K RAM, the basics</span>
<span class="co1">; (Such as Tetris)</span>
    ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE
&nbsp;
<span class="co1">; here begins our program:</span>
inicio:
    <span class="kw1">nop</span>
    <span class="kw1">di</span>                      <span class="co1">; disables interrupts</span>
    <span class="kw1">ld</span>      <span class="kw3">sp</span>, $ffff       <span class="co1">; We aim pile atop the ram initialization:</span>
&nbsp;
inicializacion:
&nbsp;
    <span class="co1">; We started the timer</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>rTAC<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">;  off timer, divider to 00 (4096 Hz)</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 51
    <span class="kw1">ld</span>      <span class="br0">[</span>rTMA<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; when TIMA overflows, this is </span>
                            <span class="co1">; reset value, (1/4096) * (255-51) = 0,049 s</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rTIMA<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; initial value of the timer.</span>
&nbsp;
    <span class="co1">; begin the variables</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_CONTROL_TIEMPO<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_ACTIVADO<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_MINUTOS<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_HORAS<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; pallet</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %11100100    <span class="co1">; Palette colors from the darkest to</span>
                            <span class="co1">; Lighter, 11 10 01 00</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; We write this in the background palette register</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rOBP0<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; and sprite palette 0</span>
&nbsp;
    <span class="co1">; scroll</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">;  We write 0 to scroll records X and Y</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; whereby the visible screen positioned</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; at the beginning (upper left) of the fund.</span>
&nbsp;
    <span class="co1">; video</span>
    <span class="kw1">call</span>    apaga_LCD       <span class="co1">; We call the routine that turns off the LCD</span>
&nbsp;
    <span class="co1">; the tiles loaded in memory</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Tiles       <span class="co1">; HL loaded in the direction of our tile</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _VRAM       <span class="co1">; address in the video memory</span>
    <span class="kw1">ld</span>      <span class="kw3">bc</span>, FinTiles-Tiles  <span class="co1">; number of bytes to copy</span>
&nbsp;
    <span class="kw1">call</span>    CopiaMemoria
&nbsp;
    <span class="co1">; We clean the map</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _SCRN0      <span class="co1">; map 0</span>
    <span class="kw1">ld</span>      <span class="kw3">bc</span>, 32*32
    <span class="kw1">ld</span>      <span class="kw3">l</span>, <span class="nu0">11</span>           <span class="co1">; empty tile</span>
    <span class="kw1">call</span>    RellenaMemoria
&nbsp;
    <span class="co1">; well, we all loaded map tiles</span>
    <span class="co1">; sprite attribute memory</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _OAMRAM     <span class="co1">; sprite attribute memory</span>
    <span class="kw1">ld</span>      <span class="kw3">bc</span>, <span class="nu0">40</span>*<span class="nu0">4</span>        <span class="co1">;  40 sprites x 4 bytes each</span>
    <span class="kw1">ld</span>      <span class="kw3">l</span>, <span class="nu0">0</span>            <span class="co1">; we will start fresh, so the sprites</span>
    <span class="kw1">call</span>    RellenaMemoria  <span class="co1">; Unused remain off-screen</span>
&nbsp;
    <span class="co1">; We draw the stopwatch</span>
    <span class="kw1">call</span>    DibujaCronometro
&nbsp;
    <span class="co1">; configure and activate the display</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
<span class="co1">; main control loop:</span>
control:
    <span class="co1">; We read the pad</span>
    <span class="kw1">call</span>    lee_pad
&nbsp;
    <span class="co1">; Now activate or deactivate the timer</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %00000001       <span class="co1">; Button A</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, Activa
&nbsp;
    <span class="co1">; Reset</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %00000010       <span class="co1">; Button B</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, Resetea
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">bc</span>, 15000
    <span class="kw1">call</span>    retardo
    <span class="co1">; we start</span>
    <span class="kw1">jr</span>      control
&nbsp;
&nbsp;
<span class="co1">; Timer control routine</span>
Activa:
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_ACTIVADO<span class="br0">]</span>
    <span class="kw1">cp</span>      1
    <span class="kw1">jp</span>      <span class="kw5">z</span>, .desactiva       <span class="co1">; If enabled, disable it</span>
    <span class="co1">; if not, activate</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 1
    <span class="kw1">ld</span>      <span class="br0">[</span>_ACTIVADO<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00000100    <span class="co1">; timer activated</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rTAC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>,  %00000101   <span class="co1">; VBlank timer interrupts and</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rIE<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ei</span>                      <span class="co1">; activate the interruptions</span>
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
.desactiva
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_ACTIVADO<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00000000    <span class="co1">; timer disabled</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rTAC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>,  %00000101   <span class="co1">; VBlank timer interrupts and</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rIE<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">di</span>                      <span class="co1">; deactivate the interruptions</span>
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; resets the timer</span>
Resetea:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_MINUTOS<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_HORAS<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">51</span>           <span class="co1">; initial value of the timer</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rTIMA<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; look if activated</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_ACTIVADO<span class="br0">]</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>
    <span class="co1">; if not, we redraw</span>
    <span class="kw1">call</span> EsperaVBlank
    <span class="kw1">call</span> DibujaCronometro
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
DibujaCronometro:
    <span class="co1">; dozens of hours</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_HORAS<span class="br0">]</span>
    <span class="kw1">and</span>     $F0
    swap    <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; hours</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_HORAS<span class="br0">]</span>
    <span class="kw1">and</span>     $0F
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+1<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; :</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 10
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+2<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; tens of minutes</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_MINUTOS<span class="br0">]</span>
    <span class="kw1">and</span>     $F0
    swap    <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+3<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; minutes</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_MINUTOS<span class="br0">]</span>
    <span class="kw1">and</span>     $0F
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+4<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; :</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 10
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+5<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; tens of seconds</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>
    <span class="kw1">and</span>     $F0
    swap    <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+6<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; seconds</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>
    <span class="kw1">and</span>     $0F
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+7<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Controls the time</span>
ControlTimer:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_CONTROL_TIEMPO<span class="br0">]</span>
    <span class="kw1">cp</span>      <span class="nu0">20</span>                      <span class="co1">; interruptions every 20 passes 1 sec</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .incrementa
    <span class="kw1">inc</span>     <span class="kw3">a</span>                       <span class="co1">; if not, we increased and become</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_CONTROL_TIEMPO<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ret</span>
.incrementa
    <span class="co1">; we reset the counter</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_CONTROL_TIEMPO<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; we increased the latter</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>
    <span class="kw1">inc</span>     <span class="kw3">a</span>
    <span class="kw1">daa</span>
    <span class="kw1">cp</span>      <span class="nu0">96</span>              <span class="co1">; 60 seconds have passed? (96 because we use BCD)</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .minutos     <span class="co1">; if you control the minutes</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; no, we keep and return</span>
    <span class="kw1">ret</span>
.minutos
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; minute, seconds increase to 0</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_MINUTOS<span class="br0">]</span>
    <span class="kw1">inc</span>     <span class="kw3">a</span>
    <span class="kw1">daa</span>
    <span class="kw1">cp</span>      <span class="nu0">96</span>              <span class="co1">; 60 minutes have passed?</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .horas       <span class="co1">; if you control the hours</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="br0">[</span>_MINUTOS<span class="br0">]</span>, <span class="kw3">a</span>   <span class="co1">; no, we keep and return</span>
    <span class="kw1">ret</span>
.horas
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_MINUTOS<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; minute, seconds increase to 0</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_HORAS<span class="br0">]</span>
    <span class="kw1">inc</span>     <span class="kw3">a</span>
    <span class="kw1">daa</span>
    <span class="kw1">cp</span>      <span class="nu0">36</span>              <span class="co1">; 24 hours have passed? (36 equals 24 BCD)</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .reset       <span class="co1">; if you start to re-</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="br0">[</span>_HORAS<span class="br0">]</span>, <span class="kw3">a</span>   <span class="co1">; no, we keep and return</span>
    <span class="kw1">ret</span>
.reset
    <span class="kw1">call</span>    Resetea
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Routine reading pad</span>
lee_pad:
    <span class="co1">; a zero</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_PAD<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; we will read the crosshead:</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00100000    <span class="co1">; bit 4-0, 5-1 bit (on crosshead, buttons not)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; now see the status of the cross, to avoid bouncing</span>
    <span class="co1">; We do several readings</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
&nbsp;
    <span class="kw1">and</span>     $0F             <span class="co1">; only care about the bottom 4 bits.</span>
    swap    <span class="kw3">a</span>               <span class="co1">; lower and upper exchanged.</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="kw3">a</span>            <span class="co1">; We keep the state of the cross in b</span>
    <span class="co1">; we go for the buttons</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00010000    <span class="co1">; bit 4 to 1, bit 5 to 0 (enabled buttons, not Cross)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; We read several times to avoid bouncing</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
&nbsp;
    <span class="co1">; we at A, the state of the buttons</span>
    <span class="kw1">and</span>     $0F             <span class="co1">; only care about the bottom 4 bits.</span>
    <span class="kw1">or</span>      <span class="kw3">b</span>               <span class="co1">; or make a to b, to "meter" in Part</span>
                            <span class="co1">; A top of the crosshead state.</span>
&nbsp;
    <span class="co1">; we now have at A, the state of all, we complement and</span>
    <span class="co1">; store it in the variable</span>
    cpl
    <span class="kw1">ld</span>      <span class="br0">[</span>_PAD<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; we reset the pad</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,$30
    <span class="kw1">ld</span>      <span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; return</span>
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; LCD shutdown routine</span>
apaga_LCD:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
    <span class="kw1">rlca</span>                    <span class="co1">;It sets the high bit of LCDC in the carry flag</span>
    <span class="kw1">ret</span>     <span class="kw5">nc</span>              <span class="co1">; Display is already off, again.</span>
&nbsp;
    <span class="co1">; We VBlank hope to, because we can not turn off the screen</span>
    <span class="co1">; some other time</span>
    <span class="kw1">call</span>    EsperaVBlank
&nbsp;
    <span class="co1">; we are in VBlank, we turn off the LCD</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>       <span class="co1">;
in A, the contents of the LCDC</span>
    <span class="kw1">res</span>     7,<span class="kw3">a</span>             <span class="co1">; we zero bit 7 (on the LCD)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>       <span class="co1">; We wrote in the LCDC register content A</span>
&nbsp;
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
EsperaVBlank:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, EsperaVBlank
    <span class="kw1">ret</span>
&nbsp;
&nbsp;
<span class="co1">; delay routine</span>
<span class="co1">; parameters</span>
<span class="co1">; bc - number of iterations</span>
retardo:
.delay:
    <span class="kw1">dec</span>     <span class="kw3">bc</span>              <span class="co1">; decrement</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">b</span>            <span class="co1">; see if zero</span>
    <span class="kw1">or</span>      <span class="kw3">c</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_delay
    <span class="kw1">nop</span>
    <span class="kw1">jr</span>      .delay
.fin_delay:
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; memory copy routine</span>
<span class="co1">; copy a number of bytes from one direction to another</span>
<span class="co1">; expects the parameters:</span>
<span class="co1">; hl - copying data address</span>
<span class="co1">; of - destination address</span>
<span class="co1">; bc - amount of data to be copied</span>
<span class="co1">; destroys the contents of A</span>
CopiaMemoria:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>     <span class="co1">; 
To load the data in A</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>     <span class="co1">; 
copy the data to the destination</span>
    <span class="kw1">dec</span>     <span class="kw3">bc</span>          <span class="co1">; least one copy</span>
    <span class="co1">; We check if bc is zero</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">c</span>
    <span class="kw1">or</span>      <span class="kw3">b</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>           <span class="co1">; If zero, we return</span>
    <span class="co1">; if not, we still</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>
    <span class="kw1">jr</span>      CopiaMemoria
&nbsp;
&nbsp;
<span class="co1">; Fill routine memory</span>
<span class="co1">; filled a number of bytes of memory with a data</span>
<span class="co1">; expects the parameters:</span>
<span class="co1">; of - destination address</span>
<span class="co1">; bc - amount of data to fill</span>
<span class="co1">; l - data to fill</span>
RellenaMemoria:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">l</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>     <span class="co1">; puts the data in the destination</span>
    <span class="kw1">dec</span>     <span class="kw3">bc</span>          <span class="co1">; least one fill</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">c</span>
    <span class="kw1">or</span>      <span class="kw3">b</span>           <span class="co1">; We check if bc is zero</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>           <span class="co1">; If zero return</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>          <span class="co1">; if not, we still</span>
    <span class="kw1">jr</span>      RellenaMemoria
&nbsp;
&nbsp;
Tiles:
<span class="co1">; numbers 0 through 9 format tiles of RGBDS</span>
<span class="co1">; 0</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `03000330
<span class="kw4">DW</span>  `03003030
<span class="kw4">DW</span>  `03030030
<span class="kw4">DW</span>  `03300030
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00000000
<span class="co1">; 1</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00003000
<span class="kw4">DW</span>  `00033000
<span class="kw4">DW</span>  `00003000
<span class="kw4">DW</span>  `00003000
<span class="kw4">DW</span>  `00003000
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00000000
<span class="co1">; 2</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `00003300
<span class="kw4">DW</span>  `00030000
<span class="kw4">DW</span>  `00300000
<span class="kw4">DW</span>  `03333330
<span class="kw4">DW</span>  `00000000
<span class="co1">; 3</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `00003300
<span class="kw4">DW</span>  `00000030
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00000000
<span class="co1">; 4</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000300
<span class="kw4">DW</span>  `00003300
<span class="kw4">DW</span>  `00030300
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00000300
<span class="kw4">DW</span>  `00000300
<span class="kw4">DW</span>  `00000000
<span class="co1">; 5</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `03333330
<span class="kw4">DW</span>  `03000000
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00000030
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00000000
<span class="co1">; 6</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00003000
<span class="kw4">DW</span>  `00030000
<span class="kw4">DW</span>  `00300000
<span class="kw4">DW</span>  `03333300
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00000000
<span class="co1">; 7</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `03333330
<span class="kw4">DW</span>  `00000300
<span class="kw4">DW</span>  `00003000
<span class="kw4">DW</span>  `00030000
<span class="kw4">DW</span>  `00300000
<span class="kw4">DW</span>  `00300000
<span class="kw4">DW</span>  `00000000
<span class="co1">; 8</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00000000
&nbsp;
<span class="co1">; 9</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `03000030
<span class="kw4">DW</span>  `00333300
<span class="kw4">DW</span>  `00003000
<span class="kw4">DW</span>  `00330000
<span class="kw4">DW</span>  `00000000
&nbsp;
<span class="co1">; :</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00033000
<span class="kw4">DW</span>  `00033000
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00033000
<span class="kw4">DW</span>  `00033000
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000000
&nbsp;
<span class="co1">; empty tile</span>
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000000
<span class="kw4">DW</span>  `00000000
&nbsp;
FinTiles:</pre>
</dd></dl>

<p>
ROM: <a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=hola-timer.gb" class="media mediafile mf_gb" title="hola-timer.gb">hola-timer.gb</a>
</p>

<p>
Result:
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=cronometro.png" class="media" title="cronometro.png"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch_002.png" class="media" alt=""></a>
</p>

</div>

<h3><a name="explicacion1" id="explicacion1">Explanation</a></h3>
<div class="level3">

<p>

I've been told it would be nice to explain a couple of functions, so let's do this:
</p>

<p>
First I will explain ControlTimer, because it will help us to better explain the other.
</p>
<pre class="code asm"><span class="co1">; Controls the time</span>
ControlTimer:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_CONTROL_TIEMPO<span class="br0">]</span>
    <span class="kw1">cp</span>      <span class="nu0">20</span>                      <span class="co1">; interruptions every 20 passes 1 sec </span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .incrementa
    <span class="kw1">inc</span>     <span class="kw3">a</span>                       <span class="co1">; if not, we increased and become </span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_CONTROL_TIEMPO<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ret</span></pre>

<p>
As explained above, we have the timer to 4096Hz and the timer initial value 51, calls the interrupt timer each approximately .05 seconds, so to count from 1 to 1 seconds to the timer, what we do here is count the times that calls this subroutine, if it has been called 20 times, it's been 0.05 * 20 = 1 second, so let's change the time, if not, increment the counter and return. 
</p>
<pre class="code asm">&nbsp;
.incrementa
    <span class="co1">; we reset the counter</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_CONTROL_TIEMPO<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; we increased the latter </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>
    <span class="kw1">inc</span>     <span class="kw3">a</span>
    <span class="kw1">daa</span>
    <span class="kw1">cp</span>      <span class="nu0">96</span>              <span class="co1">; 60 seconds have passed? (96 because we use BCD)</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .minutos     <span class="co1">; if you control the minutes</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; no, we keep and return</span>
    <span class="kw1">ret</span></pre>

<p>
Well, now we will increase the time that has already passed one second, first we reset the counter of times that calls the function, because they have as 20th, we need to recount from zero. 
</p>

<p>
Then we will increase the latter. A charge in the second, and we add one, then we have to see if the result is greater than 60, because if so, we have to set seconds to zero, and adding a minute. But you see daa use. DAA is an instruction that it does is convert the contents of A BCD (Binary Coded Decimal), if you know BCD, binary numbers instead of stored as is, stored in a byte so that each 4 bits represent a number from 0 to 9, and not from 0 to 15 as base 2 could be ordinary. This is very useful because although one byte can only store of 0-99 in each nibble I have tens and units respectively in the number of seconds / minutes / hours, and this will be very useful and then draw them. So I turn the content of A BCD and compare it to 60 (in BCD is 0110 (6) and 0000 (0), 01.1 million and that is 96 represented normal binary, which is what means the processor to compare that binary content is equal, so I compare with 96), if we have more than 60 seconds, jump to increase the minutes, if not, I keep the result in the second, and again. 
</p>
<pre class="code asm">&nbsp;
.minutos
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_SEGUNDOS<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; ; minute, seconds increase to 0</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_MINUTOS<span class="br0">]</span>
    <span class="kw1">inc</span>     <span class="kw3">a</span>
    <span class="kw1">daa</span>
    <span class="kw1">cp</span>      <span class="nu0">96</span>              <span class="co1">; 60 minutes have passed?</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .horas       <span class="co1">; if you control the hours</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="br0">[</span>_MINUTOS<span class="br0">]</span>, <span class="kw3">a</span>   <span class="co1">; no, we keep and return</span>
    <span class="kw1">ret</span>
.horas
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_MINUTOS<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; minute, seconds increase to 0
</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_HORAS<span class="br0">]</span>
    <span class="kw1">inc</span>     <span class="kw3">a</span>
    <span class="kw1">daa</span>
    <span class="kw1">cp</span>      <span class="nu0">36</span>              <span class="co1">; 24 hours have passed? (36 corresponds to 24 in BCD) </span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .reset       <span class="co1">; if you start to re-</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="br0">[</span>_HORAS<span class="br0">]</span>, <span class="kw3">a</span>   <span class="co1">; no, we keep and return</span>
    <span class="kw1">ret</span>
.reset
    <span class="kw1">call</span>    Resetea
&nbsp;
    <span class="kw1">ret</span></pre>

<p>
And here it is almost the same for the minutes and hours. For minutes, the first thing I do is set seconds to zero (59-> 0) and then increase the minutes and do the same thing with the second, check if it has been 60 and afrimativo case go to increase the hours, and if not return. And with the same hours, only if they spend 24 hours, reset, I put everything to zero, and ale, to start over.
</p>

<p>
And now explain the routine that draws the clock, which is very simple. At the beginning I defined a constant named _POS_CRONOM, such that _SCRN0 + 32 * 4 + 6. What does that mean?_SCRN0 Was the address in memory of the background map, where it is kept that tile paint at each position 32 * 32 tiles background. If I add that 32 * 4, get 32 ​​bytes later * 4 = fourth line, and if most 6 because the fourth line of the screen, the 6-position, the point where start to draw the stopwatch. And from here it is very simple. I have to start drawing on the tens of hours, then hours, then the two points, then tens of minutes ... etc. For seeing the beginning of the routine:
</p>
<pre class="code asm">    <span class="co1">; dozens of hours </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_HORAS<span class="br0">]</span>
    <span class="kw1">and</span>     $F0
    swap    <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; hours</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_HORAS<span class="br0">]</span>
    <span class="kw1">and</span>     $0F
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+1<span class="br0">]</span>, <span class="kw3">a</span>
    <span class="co1">; :</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 10
    <span class="kw1">ld</span>      <span class="br0">[</span>_POS_CRONOM+2<span class="br0">]</span>, <span class="kw3">a</span></pre>

<p>
Position on the record, the contents of variable hours, as it is stored in BCD, I know I have the tens of hours and lower units in the upper nibble. So to draw tens, I do a and of its contents with $ F0, which is% 11110000, so this clears the contents of the middle bottom, leaving just the middle top, and then doing swap, change the middle part the average high floor, so now I have in A, only the number of tens of hours.Then simply charge _POS_CRONOM that number in the position that I shall bring that number at that location map screen. We know that the gameboy, drawn background picking the tiles from the list according to the number of tiles that say you, then get into that position of the tile background equal to the number of tens of hours. As our tiles 0 through 9 of the drawings are precisely the numbers 0 through 9, the gameboy drawn in that position number corresponding to the tens of hours. Then for units of hours, do something similar, but what we do is the opposite and, with $ 0F, because we only want to stay with the bottom (units) and then we need the swap and draw directly to the corresponding tile number, but now en_POS_CRONOM + 1, because we want to draw a position further to the right. Then we draw the colon (tile 10), and do the same for tens of minutes, units of minutes, etc., simply by adding positions to the initial direction to draw the remaining numbers. 
</p>

<p>
And even here this example. Next, banks.
</p>

</div>

<h1><a name="hola_bancos" id="hola_bancos">Hola Banks</a></h1>
<div class="level1">

<p>
As had been mentioned, the Gameboy only can directly handle a 64K address space, and they have to handle RAM, video memory, registers input / output, etc., so that the cartridge data, we have available only 32K, organized into two 16K blocks, one of $ 0000 to $ 3FFF and another $ 4000 to $ 7FFF. 
</p>

<p>
Then, when we need more memory for our programs, we have to use the mappers known. A mapper is a chip that resides in the cartridge, and listening certain "commands" that you can send to let us dispobible more memory cartridges at our request. This is achieved by banking. Let's assume that the first block of 16K the $ 0000 to $ 3FFF, is a fixed block that is always available at the beginning of the cartridge memory in that direction. But in the second block, from $ 4000 to $ 7FFF, we can map other areas of the memory cartridge, called banks. In the GameBoy, these banks are always 16K. So for example: If we have a cartridge with a 64K memory, we divide it into 4 blocks of 16K, and we, the block 0 of $ 0000 to $ 3FFF in the cartridge memory, always available in the memory of the gameboy $ 0000 to $ 3FFF, but the other 3 blocks, 1, 2 and 3, we can exchange them in the memory range of the gameboy $ 4000 to $ 7FFF, thus being able to access on that block to the top three banks cartridge memory, one by one when we need them. 
</p>

<p>
To do so, as I said, we need a mapper. During the existence of the Gameboy, varioas of these chips were developed by growing needs. The best known are the MBC1 mappers, the MBC2, the MBC3 and MBC5 appeared as the GameBoy Color. The good thing is that most of these mappers are very similar to each other, only that increasingly allow more memory, but the basic access is often supported. Besides these mappers, they would introduce a very important feature. The allow the use of external RAM in the cartridge, normally protected by a battery so that it retains its contents when you turn off the console, with what we have saved games or important data. 
</p>

<p>
Then we go with the example. The first thing you'll notice is that I changed the head of the cartridge, saying that we now have a cartridge with MBC1 mapper, external RAM and battery cartridge has 64K of ROM and 8K of RAM. We need to define the header correctly in these areas, although the actual GameBoy ignores them and allows us to do things, emulators usually ignore him and just let you use and saving banks if these data are correct. 
</p>

<p>
Meto all possible code zero bank, to start my program with the initial address as always, the linker will place me everything in bank 0 unless told otherwise. 
</p>

<p>
Then at the end of the program, you can see that two banks and define policies and define them. As I told you the top banks to 0, always tendrñan to be mapped in the second block of addresses $ 4000 to $ 7FFF, so I put the start address, but also tell the RGBDS in reality I put that data in X bank in the rom generated. So in ROM cartridge, really bank 0 will be of $ 0000 to $ 3FFF, bank 1 of $ 4000 to $ 7FFF, the bank 2 $ 8000 to BFFF $, etc, but when using the mapper to access those banks, the "will place" in memory of the gameboy $ 4000 to $ 7FFF. 
</p>

<p>
So the program starts and as usual, the default when you start the console, the mapper placed bank 1 then 0, so if we print the message contained in $ 4000, says that is in the bank 1. Now pressing A or B, we can send the commands that tell the mapper change the bank, so now if we print the message in $ 4000, we can be content start printing bank 1 or 2, so that the message changes. Ademñas, if you click Select, we keep the number of the current bank in the external memory, so when encendais the GameBoy (or emulator) again, you will see that "remembers" the last bank number you had selected when you gave to "record "with Select. 
</p>

<p>
Select a bank with MBC1 is simple, simply write the number of the bank you want to select, in the memory address $ 2000. As is nonsense writing in that direction, because in theory are writing in ROM cartridge, which is impossible because it is read-only, the mapper listens to this write attempt and select a bank or another depending on the number you try to write. Very simple.
</p>

<p>
Then for memory, there is a difference, and we have to activate it. This is done to avoid unnecessary memory accesses, power failures or possible (batteries) that could cause data loss, so when we want to access external memory, activate, read or write, and deactivate. This is accomplished by "writing" A $ 0A at $ 0000 to activate the external memory, and $ 00 at $ 0000 to clear it, and then simply read or write data from $ A000 to $ BFFF. We also have banks of RAM if we need more, and work just like ROM banks but in blocks of 8K, using $ 4000 to select (there writing the bank number we want).
</p>

<p>
Also I added a little something to this example, as routines to print text strings, or a complete source ASCII characters from 32 (space) to 127. I have done very simple, use the second memory block tiles from $ 8800 to $ 97FF which we know uses numbers from -128 to 127, so zero is $ 9,000. If colo space (ascii 32), 32 tiles above (each tile is 2 bytes per line and 8 lines, 32 * 2 * 8), so at $ 9200, I use normal text in my data to write in the background, as the number of ascii character, match the tile number to draw.What you see on the labels with text I use, I write the text as quoted. The RGBDS will convert these characters to their ASCII values ​​to get them as if byte DB tuck hand. The strings just to 0 (using the comma to add a byte more), so that the printing routines, know where you finish printing. 
</p>

<p>
To generate the source, I created a little program in java, which takes an image of 768 × 8 pixels (96 tiles 8 × 8) grayscale, and we generate data useful in RGBDS format. I will publish soon. 
</p>

<p>
I leave the code example: 
</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=42" title="Descargar trozo de código fuente" class="mediafile mf_asm">holabancos.asm</a></dt>
<dd><pre class="code asm"><span class="co1">; Hello Banks</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; For the tutorial(Spanish): </span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span>
&nbsp;
<span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>          <span class="co1">; import file definitions</span>
&nbsp;
<span class="co1">; Constantes</span>
_TILES_FUENTE      <span class="kw4"> EQU</span>     $<span class="nu0">9200</span>       <span class="co1">; the second table is useful to $8800</span>
                                        <span class="co1">; to $97FF and the tiles are numbered</span>
                                        <span class="co1">; from -128 to 127, with tile 0</span>
                                        <span class="co1">; it is $9000. If I add 32 tiles</span>
                                        <span class="co1">; (32 * 2 bytes * 8lineas) and placed there</span>
                                        <span class="co1">; the first character (space), I</span>
                                        <span class="co1">; match the ASCII code</span>
                                        <span class="co1">;  and I can use text strings as is</span>
<span class="co1">; Variables</span>
_BANCO             <span class="kw4"> EQU</span>     _RAM        <span class="co1">; We will keep the current bank</span>
_PAD               <span class="kw4"> EQU</span>     _RAM+<span class="nu0">1</span>      <span class="co1">; State pad</span>
&nbsp;
<span class="co1">; interruption VBlank</span>
SECTION <span class="st0">"Vblank"</span>,HOME<span class="br0">[</span>$0040<span class="br0">]</span>
    <span class="kw1">reti</span>     <span class="co1">; we do nothing, we return</span>
&nbsp;
<span class="co1">; The program begins here:</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>      inicio
&nbsp;
<span class="co1">; Head of the ROM (Macro defined in gbhw.inc)</span>
<span class="co1">; defines a MBC1 rom mapper, and 64K RAM</span>
    ROM_HEADER  ROM_MBC1_RAM_BAT, ROM_SIZE_64KBYTE, RAM_SIZE_8KBYTE
&nbsp;
<span class="co1">; Here begins our program</span>
inicio:
    <span class="kw1">nop</span>
    <span class="kw1">di</span>                      <span class="co1">; disables interrupts</span>
    <span class="kw1">ld</span>      <span class="kw3">sp</span>, $ffff       <span class="co1">; We aim pile atop the ram</span>
&nbsp;
inicializacion:
&nbsp;
    <span class="co1">; We began variables</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 1
    <span class="kw1">ld</span>      <span class="br0">[</span>_BANCO<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; paletas</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %11100100    <span class="co1">; Palette colors from the darkest to</span>
                            <span class="co1">; lighter, 11 10 01 00</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; We write this in the background palette register </span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rOBP0<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; and sprite palette 0</span>
&nbsp;
    <span class="co1">; scroll</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="nu0">0</span>            <span class="co1">; write 0 records scroll in X and Y</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; positioned so that the visible screen</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>       <span class="co1">; at the beginning (upper left) of the fund.</span>
&nbsp;
    <span class="co1">; video</span>
    <span class="kw1">call</span>    apaga_LCD       <span class="co1">; We call the routine that turns off the LCD</span>
&nbsp;
    <span class="co1">; We load the tiles in the second table memory tiles</span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Fuente1     <span class="co1">; HL loaded in the direction of our tile</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _TILES_FUENTE       <span class="co1">; in direction of the table</span>
    <span class="kw1">ld</span>      <span class="kw3">bc</span>, EndFuente1-Fuente1  <span class="co1">; number of bytes to copy</span>
&nbsp;
    <span class="kw1">call</span>    CopiaMemoria
&nbsp;
    <span class="co1">; We clean the map</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _SCRN0      <span class="co1">; map 0</span>
    <span class="kw1">ld</span>      <span class="kw3">bc</span>, 32*32
    <span class="kw1">ld</span>      <span class="kw3">l</span>, <span class="nu0">0</span>            <span class="co1">; tile vacuum (space)</span>
    <span class="kw1">call</span>    RellenaMemoria
&nbsp;
    <span class="co1">; well, we all loaded map tiles</span>
    <span class="co1">; We clean the memory of sprites</span>
    <span class="kw1">ld</span>      <span class="kw3">de</span>, _OAMRAM     <span class="co1">; sprite attribute memory</span>
    <span class="kw1">ld</span>      <span class="kw3">bc</span>, <span class="nu0">40</span>*<span class="nu0">4</span>        <span class="co1">; 40 sprites x 4 bytes each</span>
    <span class="kw1">ld</span>      <span class="kw3">l</span>, <span class="nu0">0</span>            <span class="co1">; we will start fresh, so the sprites</span>
    <span class="kw1">call</span>    RellenaMemoria  <span class="co1">; Unused fall outside screen</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, $4000
    <span class="kw1">call</span>    ImprimeCadena
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 16
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Info
    <span class="kw1">call</span>    ImprimeCadena
&nbsp;
    <span class="co1">; we will read the data stored </span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, $0A
    <span class="kw1">ld</span>      <span class="br0">[</span>$0000<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; activate external RAM</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>$A000<span class="br0">]</span>      <span class="co1">; We carry in to the data</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="kw3">a</span>            <span class="co1">; we keep</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, $00
    <span class="kw1">ld</span>      <span class="br0">[</span>$0000<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; deactivate the external RAM</span>
&nbsp;
    <span class="co1">; we print </span>
    <span class="kw1">ld</span>      <span class="kw3">l</span>, <span class="kw3">b</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 18
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 16
    <span class="kw1">call</span>    ImprimeNumero
&nbsp;
    <span class="co1">; configure and activate the display</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8800|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
<span class="co1">; main loop</span>
control:
    <span class="co1">; We read the pad</span>
    <span class="kw1">call</span>    lee_pad
&nbsp;
    <span class="co1">; Now we switch to bank 1</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %00000001       <span class="co1">; A button</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, Banco1
&nbsp;
    <span class="co1">; Or at Bank 2</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %00000010       <span class="co1">; B button</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, Banco2
&nbsp;
    <span class="co1">; Stored in the external RAM</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_PAD<span class="br0">]</span>
    <span class="kw1">and</span>     %000000100       <span class="co1">; Select button</span>
    <span class="kw1">call</span>    <span class="kw5">nz</span>, Guarda
&nbsp;
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">bc</span>, 15000
    <span class="kw1">call</span>    Retardo
    <span class="co1">; we start</span>
    <span class="kw1">jr</span>      control
&nbsp;
&nbsp;
<span class="co1">; Switch to bank 1 and displays</span>
Banco1:
    <span class="co1">; the bank wrote in the direction we want Bank Select</span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, $2000
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, 01        <span class="co1">; Bank 1</span>
&nbsp;
    <span class="co1">; store it in the variable</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 01
    <span class="kw1">ld</span>      <span class="br0">[</span>_BANCO<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; We show the message that lies at the beginning of the upper bank</span>
    <span class="kw1">call</span>    EsperaVBlank
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, $4000
    <span class="kw1">call</span>    ImprimeCadena
&nbsp;
    <span class="co1">; we have changed, delete the message saved if any</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 12
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Limpia
    <span class="kw1">call</span>    ImprimeCadena
&nbsp;
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Switch to bank 2 and displays</span>
Banco2:
    <span class="co1">; the same but select bank 2 </span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, $2000
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, 02
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 02
    <span class="kw1">ld</span>      <span class="br0">[</span>_BANCO<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="kw1">call</span>    EsperaVBlank
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, $4000
    <span class="kw1">call</span>    ImprimeCadena
&nbsp;
    <span class="co1">; we have changed, delete the message saved if any</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 12
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Limpia
    <span class="kw1">call</span>    ImprimeCadena
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Save the number of actual bank in the cartridge memory</span>
Guarda:
    <span class="co1">; first we activate the external SRAM</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, $0A          <span class="co1">; $0A, activate</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>$0000<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; </span>
&nbsp;
    <span class="co1">; Write the data in the first byte of the external ram</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_BANCO<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>$A000<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; We deactivate the SRAM</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, $00          <span class="co1">; $00 off</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>$0000<span class="br0">]</span>, <span class="kw3">a</span>      <span class="co1">; </span>
&nbsp;
    <span class="co1">; we print</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>_BANCO<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">l</span>,  <span class="kw3">a</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 18
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 16
    <span class="kw1">call</span>    ImprimeNumero
&nbsp;
    <span class="co1">; show message</span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, 1
    <span class="kw1">ld</span>      <span class="kw3">c</span>, 12
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, Guardado
    <span class="kw1">call</span>    ImprimeCadena
&nbsp;
    <span class="kw1">ret</span>
&nbsp;
&nbsp;
&nbsp;
<span class="co1">; Prints a string on the bottom (string ending in 0)</span>
<span class="co1">; Parameters:</span>
<span class="co1">; b - x coordinate</span>
<span class="co1">; c - y coordinate</span>
<span class="co1">; hl - chain management</span>
ImprimeCadena:
    <span class="kw1">push</span>    <span class="kw3">hl</span>          <span class="co1">; then keep hl pa</span>
    <span class="co1">; we will use hl now for destination calculations</span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SCRN0
    <span class="co1">; we will position and</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">c</span>
    <span class="kw1">cp</span>      0
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_y   <span class="co1">; If zero, we go for the x</span>
.avz_y:
    <span class="kw1">ld</span>      <span class="kw3">de</span>, 32
    <span class="kw1">add</span>     <span class="kw3">hl</span>, <span class="kw3">de</span>      <span class="co1">; We move on 32 And therefore useful</span>
    <span class="kw1">dec</span>     <span class="kw3">a</span>
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .avz_y
.fin_y:
<span class="co1">; we go for the x</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">b</span>
    <span class="kw1">cp</span>      0
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_x   <span class="co1">; If zero, finished</span>
.avz_x:
    <span class="kw1">inc</span>     <span class="kw3">hl</span>
    <span class="kw1">dec</span>     <span class="kw3">a</span>
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .avz_x
.fin_x:
    <span class="kw1">push</span>    <span class="kw3">hl</span>
    <span class="kw1">pop</span>     <span class="kw3">de</span>          <span class="co1">; of = hl</span>
<span class="co1">; But we 'of' the memory location where the string writing</span>
<span class="co1">; we will do</span>
    <span class="kw1">pop</span>     <span class="kw3">hl</span>          <span class="co1">; hl rescued stack</span>
.imprime:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>     <span class="co1">; We load a character</span>
    <span class="kw1">cp</span>      0
    <span class="kw1">ret</span>     <span class="kw5">z</span>           <span class="co1">; If zero, return </span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>     <span class="co1">; if not, we print</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>          <span class="co1">; following </span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>
    <span class="kw1">jr</span>      .imprime
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Prints a number (unit)</span>
<span class="co1">; Parameters</span>
<span class="co1">; b - position x</span>
<span class="co1">; c - position y</span>
<span class="co1">; l - number to be printed (0-9)</span>
ImprimeNumero:
    <span class="kw1">push</span>    <span class="kw3">hl</span>          <span class="co1">; then keep hl pa</span>
    <span class="co1">; we will use hl now for destination calculations</span>
    <span class="kw1">ld</span>      <span class="kw3">hl</span>, _SCRN0
    <span class="co1">; we will position and</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">c</span>
    <span class="kw1">cp</span>      0
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_y   <span class="co1">; If zero, we go for the x</span>
.avz_y:
    <span class="kw1">ld</span>      <span class="kw3">de</span>, 32
    <span class="kw1">add</span>     <span class="kw3">hl</span>, <span class="kw3">de</span>      <span class="co1">; We move on 32 And therefore useful</span>
    <span class="kw1">dec</span>     <span class="kw3">a</span>
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .avz_y
.fin_y:
<span class="co1">; we go for the x</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">b</span>
    <span class="kw1">cp</span>      0
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_x   <span class="co1">; If zero, finished</span>
.avz_x:
    <span class="kw1">inc</span>     <span class="kw3">hl</span>
    <span class="kw1">dec</span>     <span class="kw3">a</span>
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, .avz_x
.fin_x:
    <span class="kw1">push</span>    <span class="kw3">hl</span>
    <span class="kw1">pop</span>     <span class="kw3">de</span>          <span class="co1">; of = hl</span>
<span class="co1">; But we 'of' the memory in which to write the number</span>
<span class="co1">; we will do</span>
    <span class="kw1">pop</span>     <span class="kw3">hl</span>          <span class="co1">; the number rescued</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">l</span>
    <span class="kw1">and</span>     $0F         <span class="co1">; we are only interested lower</span>
&nbsp;
    <span class="kw1">add</span>     <span class="kw3">a</span>, <span class="nu0">48</span>       <span class="co1">; the first space character is 32, zero is +16</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Routine reading pad</span>
lee_pad:
    <span class="co1">; a zero</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, 0
    <span class="kw1">ld</span>      <span class="br0">[</span>_PAD<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; we will read the cross:</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00100000    <span class="co1">; bit 4-0, 5-1 bit (on Cross, no buttons)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; now we read the status of the Cross, to avoid bouncing</span>
    <span class="co1">; We do several readings</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
&nbsp;
    <span class="kw1">and</span>     $0F             <span class="co1">; only care about the bottom 4 bits.</span>
    swap    <span class="kw3">a</span>               <span class="co1">; lower and upper exchange. </span>
    <span class="kw1">ld</span>      <span class="kw3">b</span>, <span class="kw3">a</span>            <span class="co1">; We keep cross status in b</span>
&nbsp;
    <span class="co1">; we go for the buttons</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, %00010000    <span class="co1">; bit 4 to 1, bit 5 to 0 (enabled buttons, not Cross)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; We read several times to avoid bouncing</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rP1<span class="br0">]</span>
&nbsp;
    <span class="co1">; we at A, the state of the buttons</span>
    <span class="kw1">and</span>     $0F             <span class="co1">; only care about the bottom 4 bits.</span>
    <span class="kw1">or</span>      <span class="kw3">b</span>               <span class="co1">; or make a to b, to "meter" in Part</span>
                            <span class="co1">; A superior, cross status.</span>
&nbsp;
    <span class="co1">; we now have at A, the state of all, we complement and</span>
    <span class="co1">; store it in the variable</span>
    cpl
    <span class="kw1">ld</span>      <span class="br0">[</span>_PAD<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; we reset the pad</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,$30
    <span class="kw1">ld</span>      <span class="br0">[</span>rP1<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
    <span class="co1">; return</span>
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; LCD shutdown routine</span>
apaga_LCD:
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
    <span class="kw1">rlca</span>                    <span class="co1">; It sets the high bit of LCDC in the carry flag</span>
    <span class="kw1">ret</span>     <span class="kw5">nc</span>              <span class="co1">; Display is already off, again.</span>
&nbsp;
    <span class="co1">;We VBlank hope to, because we can not turn off the screen</span>
    <span class="co1">; some other time</span>
    <span class="kw1">call</span>    EsperaVBlank
&nbsp;
    <span class="co1">; we are in VBlank, we turn off the LCD</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>       <span class="co1">; in A, the contents of the LCDC</span>
    <span class="kw1">res</span>     7,<span class="kw3">a</span>             <span class="co1">; we zero bit 7 (on the LCD)</span>
    <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>       <span class="co1">; We wrote in the LCDC register content A</span>
&nbsp;
    <span class="kw1">ret</span>                     <span class="co1">; return</span>
&nbsp;
EsperaVBlank:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
    <span class="kw1">cp</span>      145
    <span class="kw1">jr</span>      <span class="kw5">nz</span>, EsperaVBlank
    <span class="kw1">ret</span>
&nbsp;
&nbsp;
<span class="co1">; delay routine</span>
<span class="co1">; parameters</span>
<span class="co1">; bc - number of iterations</span>
Retardo:
.delay:
    <span class="kw1">dec</span>     <span class="kw3">bc</span>              <span class="co1">; decrement</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">b</span>            <span class="co1">; see if zero</span>
    <span class="kw1">or</span>      <span class="kw3">c</span>
    <span class="kw1">jr</span>      <span class="kw5">z</span>, .fin_delay
    <span class="kw1">nop</span>
    <span class="kw1">jr</span>      .delay
.fin_delay:
    <span class="kw1">ret</span>
&nbsp;
<span class="co1">; memory copy routine</span>
<span class="co1">; copy a number of bytes from one direction to another</span>
<span class="co1">;expects the parameters:</span>
<span class="co1">;hl - copying data address</span>
<span class="co1">;of - destination address</span>
<span class="co1">; bc - number of data to be copied</span>
<span class="co1">; destroys the contents of A</span>
CopiaMemoria:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>     <span class="co1">; To load the data in</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>     <span class="co1">; copy the data to the destination</span>
    <span class="kw1">dec</span>     <span class="kw3">bc</span>          <span class="co1">; least one copy</span>
    <span class="co1">; We check if bc is zero</span>
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">c</span>
    <span class="kw1">or</span>      <span class="kw3">b</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>           <span class="co1">; If zero, we return</span>
    <span class="co1">; if not, we still</span>
    <span class="kw1">inc</span>     <span class="kw3">hl</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>
    <span class="kw1">jr</span>      CopiaMemoria
&nbsp;
&nbsp;
<span class="co1">; Fill routine memory</span>
<span class="co1">; filled a number of bytes of memory with a data</span>
<span class="co1">; expects the parameters:</span>
<span class="co1">;of - destination address</span>
<span class="co1">; bc - amount of data to fill</span>
<span class="co1">; l - data to fill</span>
RellenaMemoria:
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">l</span>
    <span class="kw1">ld</span>      <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>     <span class="co1">; puts the data in the destination</span>
    <span class="kw1">dec</span>     <span class="kw3">bc</span>          <span class="co1">; least one fill</span>
&nbsp;
    <span class="kw1">ld</span>      <span class="kw3">a</span>, <span class="kw3">c</span>
    <span class="kw1">or</span>      <span class="kw3">b</span>           <span class="co1">; We check if bc is zero</span>
    <span class="kw1">ret</span>     <span class="kw5">z</span>           <span class="co1">; If zero return</span>
    <span class="kw1">inc</span>     <span class="kw3">de</span>          <span class="co1">;  if not, we still</span>
    <span class="kw1">jr</span>      RellenaMemoria
&nbsp;
&nbsp;
Limpia:
    <span class="kw4">DB</span> <span class="st0">"                     "</span>,0
Info:
    <span class="kw4">DB</span> <span class="st0">"Banco guardado: "</span>, 0
Guardado:
    <span class="kw4">DB</span> <span class="st0">"Guardado correcto"</span>, <span class="nu0">0</span>
&nbsp;
<span class="co1">; Font</span>
<span class="co1">; ========================================================================</span>
<span class="kw4">INCLUDE</span> <span class="st0">"fuente1.agb"</span>
&nbsp;
<span class="co1">; First Data Bank</span>
<span class="co1">; ========================================================================</span>
SECTION <span class="st0">"Banco1"</span>,<span class="kw4">CODE</span><span class="br0">[</span>$4000<span class="br0">]</span>,BANK<span class="br0">[</span>1<span class="br0">]</span>
    <span class="kw4">DB</span> <span class="st0">"Soy el banco 1"</span>,<span class="nu0">0</span>
&nbsp;
<span class="co1">; The second Banco data</span>
<span class="co1">; ========================================================================</span>
SECTION <span class="st0">"Banco2"</span>,<span class="kw4">CODE</span><span class="br0">[</span>$4000<span class="br0">]</span>,BANK<span class="br0">[</span>2<span class="br0">]</span>
    <span class="kw4">DB</span> <span class="st0">"Soy el banco 2"</span>,<span class="nu0">0</span></pre>
</dd></dl>

<p>
And the source file: <a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=fuente1.agb" class="media mediafile mf_agb" title="fuente1.agb">fuente1.agb</a>
</p>

<p>
La captura obligada:
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=bancos.png" class="media" title="bancos.png"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch_008.png" class="media" alt=""></a>
</p>

</div>

<h1><a name="hola_sonido" id="hola_sonido">Hello Sound</a></h1>
<div class="level1">

<p>

The sound of the GameBoy is a complex issue if you come to schedule a modern system where you play digital sound simply, easily mixing music and effects. The GameBoy by contrast, has a hardware sound quite simple, consisting of four separate and distinct channels each. We can control these channels at will, which is responsible for the GameBoy mix. These four channels are handled by typing values ​​in registers mapped into memory (of course), and each channel has multiple records for each of its parameters, so the subject takes a while to explain. Let us know and then we'll see channels as scheduled.
</p>
<ul>
<li class="level1"><div class="li"> Channel 1: Channel 1, Channel is a square wave with changeable cycle work, surround and portamento.</div>
</li>
<li class="level1"><div class="li"> Channel 2: A channel square wave with changeable work cycle, with surround. </div>
</li>
<li class="level1"><div class="li"> Channel 3: Channel programmable wave with a RAM table 32 steps. </div>
</li>
<li class="level1"><div class="li"> Channel 4: Channel surround white noise. </div>
</li>
</ul>

<p>
Well, for starters, I'll explain a little music theory, well, just what interests us, the duty cycle, the envelope and portamento.
</p>

<p>
The <strong>duty cycle</strong> is very simple, if we need wave is square, is just how much of the time duration of the note, we have the highest level, and how long the low level. This is expressed in percent. So in the GamebBoy we can choose working cycles of 12.5%, 25%, 50% and 75%. Let's explain this with an image stolen from out there: 
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=pwm-duty_cycle2.gif" class="media" title="pwm-duty_cycle2.gif"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch.gif" class="media" alt=""></a>
</p>

<p>
You see, the waves have the same frequency (all start at the same time), but depending on the duty cycle, some will spend more time and more time up below.
</p>

<p>

<strong>The envelope</strong> of a note is a function that applies to the extent of this, to modify and to vary along the length thereof.In short, you typically use an envelope called ADSR, of Attack , Decay , Sustain and Release , ie, attack, decay, sustain and relaxation. We will put a graphic ... Wikipedia to the rescue. If we have a normal note, would have a certain amplitude (volume) fixed, the graph of its size, would be a straight line. Now if we apply an ADSR envelope model, we would have something like this: 
</p>

<p>
<a href="http://wiki.ladecadence.net/lib/exe/detail.php?id=tutorial_de_ensamblador&amp;media=500px-adsr_envelope_graph.svg.png" class="media" title="500px-adsr_envelope_graph.svg.png"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/fetch_006.png" class="media" alt=""></a>
</p>

<p>
With so watching this, we can say that the attack is the time it takes for the note to reach its maximum amplitude, decay, is the time it takes to move from the end of the attack, to the value of support, which is the amplitude value we hold until the end of the note, and relaxation, the time it takes the note "disappear" from the just touching. With all these envelope parameters, we can model the notes so they change enough but we are playing the same frequency.
</p>

<p>
<strong>Portamento</strong> is when the pitch from one note to another, is not direct, but the frequency is changing gradually playing all intermediate sounds. This for example in a guitar is made when the finger on all frets between two notes creeps want to play. In the GameBoy hardware portamento this allows us a note vary over time and may increase or decrease set a base frequency over time, and the changes this frequency.
</p>

<p>
 Let's see then records the sound system and their functions: 
</p>

</div>

<h3><a name="canal_1_-_tono_y_portamento" id="canal_1_-_tono_y_portamento">Channel 1 - tone and portamento</a></h3>
<div class="level3">

</div>

<h4><a name="ff10_-_nr10_-_registro_de_portamento_del_canal_1_r_w" id="ff10_-_nr10_-_registro_de_portamento_del_canal_1_r_w"> $FF10 - NR10 - Registration portamento Channel 1 (R / W) </a></h4>
<div class="level4">
<pre class="code"> Bit 6-4 - Length of portamento
Bit 3 - Increase / Decrease the portamento
          0 Addiction (frequency increases)
           1: Abduction (the frequency decreases)
Bit 2-0 - Step displacement current (n: 0-7) </pre>

<p>
Duration of portamento:
</p>
<pre class="code">000: Off - frequency unchanged
001: 7.8 ms (1 / 128Hz)
010: 15.6 ms (2 / 128Hz)
011: 23.4 ms (3 / 128Hz)
100: 31.3 ms (4 / 128Hz)
101: 39.1 ms (5 / 128Hz)
110: 46.9 ms (6 / 128Hz)
111: 54.7 ms (7 / 128Hz)</pre>

<p>
Changing the original frequency (defined in NR13, NR14) at each step, it is calculated with the following formula, where X (0) is the initial and X (t-1) frequency is the last frequency: 
</p>
<pre class="code">X(t) = X(t-1) +/- X(t-1)/2^n</pre>

</div>

<h4><a name="ff11_-_nr11_-_canal_1_duracion_ciclo_de_trabajo_r_w" id="ff11_-_nr11_-_canal_1_duracion_ciclo_de_trabajo_r_w">$FF11 - NR11 - Channel 1 time / duty cycle (R / W)</a></h4>
<div class="level4">
<pre class="code">Bit 7-6 - Duty Cycle (R / W)
Bit 5-0 - Length (R) (t1: 0-63) </pre>

<p>
Duty cycle: 
</p>
<pre class="code">00: 12.5% ( _-------_-------_------- )
01: 25%   ( __------__------__------ )
10: 50%   ( ____----____----____---- ) (normal)
11: 75%   ( ______--______--______-- )</pre>

<p>
Length = (64-t1) * (1/256) second length is used only if Bit 6 in NR14 is one. 
</p>

</div>

<h4><a name="ff12_-_nr12_-_canal_1_-_envolvente_r_w" id="ff12_-_nr12_-_canal_1_-_envolvente_r_w">$FF12 - NR12 - Channel 1 - Surround (R / W)</a></h4>
<div class="level4">
<pre class="code">Bit 7-4 - Initial volume of the envelope (0-0Fh) (0 = no sound)
Bit 3 - Address the envelope (0 = Decreased, 1 = Grows)
Bit 2-0 - period (n: 0-7)
(If it is zero, the envelope does not act.) </pre>

<p>
Length of one step = n * (1/64) seconds
</p>

</div>

<h4><a name="ff13_-_nr13_-_canal_1_-_frecuencia_low_w" id="ff13_-_nr13_-_canal_1_-_frecuencia_low_w">$FF13 - NR13 - Channel 1 - Frequency (low) (W</a></h4>
<div class="level4">

<p>
Low 8 bits of the 11 bit frequency (x). The following 3 bits are NR14 ($ FF14) 
</p>

</div>

<h4><a name="ff14_-_nr14_-_canal_1_-_frecuencia_hi_r_w" id="ff14_-_nr14_-_canal_1_-_frecuencia_hi_r_w">$FF14 - NR14 - Channel 1 - Frequency (hi) (R / W)</a></h4>
<div class="level4">
<pre class="code">Bit 7 - timer (1 = Restart Sound) (W)
Bit 6 - Turns the length (R / W)
(1 = stops the sound when it reaches the length in NR11)
Bit 2-0 - 3 upper bits of frequency (x) (W)</pre>

<p>
Frequency = 131072 / (2048-x) Hz
</p>

</div>

<h3><a name="canal_2_-_tono" id="canal_2_-_tono">Channel 2 - Tone</a></h3>
<div class="level3">

<p>
This channel works just like 1, but has no record of portamento.
</p>

</div>

<h4><a name="ff16_-_nr21_-_canal_2_longitud_ciclo_de_trabajo_r_w" id="ff16_-_nr21_-_canal_2_longitud_ciclo_de_trabajo_r_w">$FF16 - NR21 - Channel 2 Length / Duty Cycle (R / W)</a></h4>
<div class="level4">
<pre class="code">Bit 7-6 - Duty Cycle (R / W)
Bit 5-0 - Length (R) (t1: 0-63) </pre>

<p>

Duty cycle:

</p>
<pre class="code">00: 12.5% ( _-------_-------_------- )
01: 25%   ( __------__------__------ )
10: 50%   ( ____----____----____---- ) (normal)
11: 75%   ( ______--______--______-- )</pre>

<p>
Length = (64-t1) * (1/256) second length is used only if Bit 6 in NR14 is one.
</p>

</div>

<h4><a name="ff17_-_nr22_-_canal_2_envolvente_r_w" id="ff17_-_nr22_-_canal_2_envolvente_r_w">$FF17 - NR22 - Channel 2 Surround (R / W)</a></h4>
<div class="level4">
<pre class="code"> Bit 7-4 - Initial volume of the envelope (0-0Fh) (0 = no sound)
 Bit 3 - Address the envelope (0 = Decreased, 1 = Grows)
 Bit 2-0 - period (n: 0-7)
           (If it is zero, the envelope does not act.) </pre>

<p>
Length of one step = n * (1/64) seconds
</p>

</div>

<h4><a name="ff18_-_nr23_-_canal_2_-_frecuencia_lo_w" id="ff18_-_nr23_-_canal_2_-_frecuencia_lo_w">$FF18 - NR23 - Channel 2 - Frequency (what) (W)</a></h4>
<div class="level4">

<p>
Low 8 bits of the 11 bit frequency (x). The following 3 bits are NR24 ($ FF19) 
</p>

</div>

<h4><a name="ff19_-_nr24_-_canal_2_-_frecuencia_hi_r_w" id="ff19_-_nr24_-_canal_2_-_frecuencia_hi_r_w">$FF19 - NR24 - Channel 2 - Frequency (hi) (R / W)</a></h4>
<div class="level4">
<pre class="code"> Bit 7 - timer (1 = Restart Sound) (W)
 Bit 6 - Turns the length (R / W)
           (1 = stops the sound when it reaches the length in NR21)
 Bit 2-0 - 3 upper bits of frequency (x) (W)</pre>

<p>
Frequency = 131072 / (2048-x) Hz
</p>

</div>

<h3><a name="canal_3_-_onda_programable" id="canal_3_-_onda_programable">Channel 3 - Programmable Wave</a></h3>
<div class="level3">

<p>
This channel can be used to play digital sound, but the length of the buffer samples (Wave RAM) is limited to 32 values ​​of 4 bits. One could use this channel to take notes if inicicalizamos normal wave memory with the values ​​of a square wave. No envelope control. 
</p>

</div>

<h4><a name="ff1a_-_nr30_-_canal_3_on_off_r_w" id="ff1a_-_nr30_-_canal_3_on_off_r_w"> $FF1A - NR30 - Channel 3 on / off (R / W) </a></h4>
<div class="level4">
<pre class="code">Bit 7 - Turns the channel (0 = Stopped, 1 = Plays) (R / W) </pre>

</div>

<h4><a name="ff1b_-_nr31_-_canal_3_-_longitud" id="ff1b_-_nr31_-_canal_3_-_longitud">$Ff1b - NR31 - Channel 3 - Length</a></h4>
<div class="level4">
<pre class="code">Bit 7-0 - Length (t1: 0-255) </pre>

<p>
Length = (256-t1) * (1/256) seconds. This value is used only if Bit 6 in NR34 is one. 
</p>

</div>

<h4><a name="ff1c_-_nr32_-_canal_3_-_nivel_de_salida_r_w" id="ff1c_-_nr32_-_canal_3_-_nivel_de_salida_r_w"> $Ff1c - NR32 - Channel 3 - Output level (R / W) </a></h4>
<div class="level4">
<pre class="code">Bit 6-5 - Select output volume (R / W) </pre>

<p>
Possible values ​​are:
</p>
<pre class="code">00: Off (no sound)
 01: 100% Volume (Data RAM wave as is)
 10: 50% Volume (Data RAM wave of displaced once right)
 11: 25% Volume (Data RAM wave of displaced twice right) </pre>

</div>

<h4><a name="ff1d_-_nr33_-_canal_3_-_frecuencia_lo_w" id="ff1d_-_nr33_-_canal_3_-_frecuencia_lo_w">$Ff1d - NR33 - Channel 3 - Frequency (what) (W)</a></h4>
<div class="level4">

<p>
Low 8 bits of the channel frequency (x). 
</p>

</div>

<h4><a name="ff1e_-_nr34_-_canal_3_-_frecuencia_hi_r_w" id="ff1e_-_nr34_-_canal_3_-_frecuencia_hi_r_w">$FF1E - NR34 - Channel 3 - Frequency (hi) (R / W)</a></h4>
<div class="level4">
<pre class="code">Bit 7 - timer (1 = Restart Sound) (W)
Bit 6 - Turns the length (R / W)
(1 = stops the sound when it reaches the length in NR11)
Bit 2-0 - 3 upper bits of frequency (x) (W) </pre>
<p>
Frequency = 131072 / (2048-x) Hz
</p>

</div>

<h4><a name="ff30-_ff3f_-_memoria_de_onda" id="ff30-_ff3f_-_memoria_de_onda">$FF30-$FF3F - Wave Memory</a></h4>
<div class="level4">

<p>
It contains the values ​​for generating the wave.
</p>

<p>
This memory is organized into 32 4-bit values ​​that reproduce high 4 bits first. 
</p>

</div>

<h3><a name="canal_4_-_ruido" id="canal_4_-_ruido">Channel 4 - Noise</a></h3>
<div class="level3">

<p>
This channel is used to play white noise. This is accomplished by varying the amplitude randomly given frequency. Depending on the frequency, noise seem more "hard" or "soft." 
</p>

<p>
You can also influence the output of random number generator, thus allowing less variation and output almost normal tone. 
</p>

</div>

<h4><a name="ff20_-_nr41_-_canal_4_-_longitud_r_w" id="ff20_-_nr41_-_canal_4_-_longitud_r_w">$FF20 - NR41 - Channel 4 - length (R / W)</a></h4>
<div class="level4">
<pre class="code">Bit 5-0 - Length (R) (t1: 0-63)</pre>

<p>
Length = (64-t1) * (1/256) second length is used only if Bit 6 in NR44 is one. 
</p>

</div>

<h4><a name="ff21_-_nr42_-_canal_4_-_envolvente_r_w" id="ff21_-_nr42_-_canal_4_-_envolvente_r_w">$FF21 - NR42 - Channel 4 - Surround (R / W)</a></h4>
<div class="level4">
<pre class="code"> Bit 7-4 - Initial volume of the envelope (0-0Fh) (0 = no sound)
 Bit 3 - Address the envelope (0 = Decreased, 1 = Grows)
 Bit 2-0 - period (n: 0-7)
           (If it is zero, the envelope does not act.)</pre>

<p>
Length of one step = n * (1/64) seconds
</p>

</div>

<h4><a name="ff22_-_nr43_-_canal_4_-_contador_polinomico_r_w" id="ff22_-_nr43_-_canal_4_-_contador_polinomico_r_w">$FF22 - NR43 - Channel 4 - polynomial counter (R / W)</a></h4>
<div class="level4">

<p>
The amplitude is randomly changes between high and low at the given frequency. A high frequency will make the "soft" noise. When bit 3 is set, the output is more regular, and some frequencies sound more like tone as noise. 

</p>
<pre class="code"> Bit 7-4 - Frequency shift clock (s)
 Bit 3 - Length counter (0 = 15 bits, 1 = 7 bits)
 Bit 2-0 - Radio frequency division (r) </pre>
<p>
Frequency = 524288 Hz / r / 2 ^ (s + 1); For r = 0, it behaves as if r = 0.5
</p>

</div>

<h4><a name="ff23_-_nr44_-_channel_4_-_contadordisparador_r_w" id="ff23_-_nr44_-_channel_4_-_contadordisparador_r_w">$FF23 - NR44 - Channel 4 - Accountant; Trigger (R / W)</a></h4>
<div class="level4">
<pre class="code"> Bit 7 - timer (1 = Restart Sound) (W)
 Bit 6 - Turns the length (R / W)
           (1 = stops the sound when it reaches the length in NR41) </pre>

</div>

<h3><a name="registros_de_control_generales_del_sonido" id="registros_de_control_generales_del_sonido">General records sound control</a></h3>
<div class="level3">

</div>

<h4><a name="ff24_-_nr50_-_control_de_volumen_5_canal_r_w" id="ff24_-_nr50_-_control_de_volumen_5_canal_r_w">$FF24 - NR50 - Volume control / 5th Channel (R / W)</a></h4>
<div class="level4">

<p>
Volume bits control the main volume of the left and right outputs.
</p>
<pre class="code"> Bit 7 - Vin out for SO2 (1 = enabled)
 Bit 6-4 - Volume of SO2 (0-7)
 Bit 3 - Vin goes by SO1 (1 = On)
 Bit 2-0 - Volume of SO1 (0-7) </pre>

<p>
The signal coming from the bus Vin cartridge, allowing external hardware in this, add a fifth channel to the four inmates of the GameBoy. 
</p>

</div>

<h4><a name="ff25_-_nr51_-_seleccion_de_salida_de_cada_canal_r_w" id="ff25_-_nr51_-_seleccion_de_salida_de_cada_canal_r_w">$FF24 - NR50 - Volume control / 5th Channel (R / W)</a></h4>
<div class="level4">

<p>
Volume bits control the main volume of the left and right outputs.

</p>
<pre class="code"> Bit 7 - Channel 4 at the outlet SO2
 Bit 6 - Channel 3 at the outlet SO2
 Bit 5 - Channel 2 to the output SO2 
 Bit 4 - Channel 1 to the output SO2
 Bit 3 - Channel 4 to the output SO1
 Bit 2 - Channel 3 to the output SO1
 Bit 1 - Channel 2 to the output SO1
 Bit 0 - Channel 1 to the output SO1 </pre>

</div>

<h4><a name="ff26_-_nr52_-_sonido_encendido_apagado" id="ff26_-_nr52_-_sonido_encendido_apagado">$FF26 - NR52 - Sound On / Off</a></h4>
<div class="level4">

<p>
If your program does not use sound GameBoy, write 00h in this register, you will save 16% or more of power consumption. Disable the sound system by resetting the bit 7 destroys the contents of all sound recordings. Furthermore, let all these records inaccessible (except the same FF26 $) while the sound system is turned off. 
</p>
<pre class="code"> Bit 7 - Turns all sound (0: Stop all sound circuits) (R / W)
 Bit 3 - Channel 4 ON (R)
 Bit 2 - Channel 3 ON (R)
 Bit 1 - Channel 2 ON (R)
 Bit 0 - Channel 1 ON (R)</pre>

<p>
Bits 0-3 of this register are only status bits, write them not activate or deactivate the sound of those channels. These flags are set to one when the flag "Trigger" channel (Bit 7 in NR14-NR44), the flag remains one as long as the length of the sound (if enabled) is activated. An envelope that has driven down to zero amplitude not deactivate this flag.
</p>

</div>

<h3><a name="ejemplo" id="ejemplo">Example</a></h3>
<div class="level3">
<p>
 Well, let an example, we rescued the sprite program, and add music, well, if this is you can call music <img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/icon_smile.gif" class="middle" alt=":-)"> What I do is go playing the notes of the scale (Do, Re, Mi, Fa, Sol, La, Si), 5th eighth time to time. I have a data line with the low values ​​of the frequency of these notes, and the high value, which is always the same notes in the 5th octave fixed stick it in the register. To use this channel 2. Pay attention to where active sound system and prepare the output from both speakers, and prepare the channel 2, length, duty cycle, envelope and put my high frequency value and functions iniciar_sonido active length, and cambia_nota function that checks if we have to play the note (depending on the constant TEMPO) and play the note and prepares NEXT.
</p>
<dl class="code">
<dt><a href="http://wiki.ladecadence.net/doku.php?do=export_code&amp;id=tutorial_de_ensamblador&amp;codeblock=43" title="Descargar trozo de código fuente" class="mediafile mf_agb">holasonido.agb</a></dt>
<dd><pre class="code asm"><span class="co1">; Hola sonido</span>
<span class="co1">; David Pello 2010</span>
<span class="co1">; ladecadence.net</span>
<span class="co1">; Para el tutorial en:</span>
<span class="co1">; http://wiki.ladecadence.net/doku.php?id=tutorial_de_ensamblador</span>
&nbsp;
<span class="kw4">INCLUDE</span> <span class="st0">"gbhw.inc"</span>                      <span class="co1">; importamos el archivo de definiciones</span>
&nbsp;
<span class="co1">; Velocidad de la musica, no es un tempo real en el sentido musical</span>
_TEMPO         <span class="kw4"> EQU</span>             <span class="nu0">20</span>
&nbsp;
<span class="co1">; definimos unas constantes para trabajar con nuestro sprite</span>
_SPR0_Y        <span class="kw4"> EQU</span>             _OAMRAM <span class="co1">; la Y del sprite 0, es el inicio de la mem de sprites</span>
_SPR0_X        <span class="kw4"> EQU</span>             _OAMRAM+1
_SPR0_NUM      <span class="kw4"> EQU</span>             _OAMRAM+2
_SPR0_ATT      <span class="kw4"> EQU</span>             _OAMRAM+<span class="nu0">3</span>
&nbsp;
<span class="co1">; creamos un par de variables para ver hacia donde tenemos que mover el sprite</span>
_MOVX          <span class="kw4"> EQU</span>             _RAM    <span class="co1">; inicio de la ram dispobible para datos</span>
_MOVY          <span class="kw4"> EQU</span>             _RAM+<span class="nu0">1</span>
&nbsp;
<span class="co1">; guarda la nota actual</span>
_NOTA          <span class="kw4"> EQU</span>             _RAM+<span class="nu0">2</span>
<span class="co1">; contador para el tempo</span>
_CONT_MUS      <span class="kw4"> EQU</span>             _RAM+<span class="nu0">3</span>
&nbsp;
<span class="co1">; El programa comienza aqui:</span>
SECTION <span class="st0">"start"</span>,HOME<span class="br0">[</span>$0100<span class="br0">]</span>
    <span class="kw1">nop</span>
    <span class="kw1">jp</span>          inicio
&nbsp;
<span class="co1">; Cabecera de la ROM (Macro definido en gbhw.inc)</span>
<span class="co1">; define una rom sin mapper, de 32K y sin RAM, lo más básico</span>
<span class="co1">; (como por ejemplo la del tetris)</span>
        ROM_HEADER  ROM_NOMBC, ROM_SIZE_32KBYTE, RAM_SIZE_0KBYTE
&nbsp;
<span class="co1">; aqui empieza nuestro programa</span>
inicio:
        <span class="kw1">nop</span>
        <span class="kw1">di</span>                                              <span class="co1">; deshabilita las interrupciones</span>
        <span class="kw1">ld</span>              <span class="kw3">sp</span>, $ffff               <span class="co1">; apuntamos la pila al tope de la ram</span>
&nbsp;
inicializacion:
        <span class="kw1">ld</span>              <span class="kw3">a</span>, %11100100    <span class="co1">; Colores de paleta desde el mas oscuro al</span>
                                                        <span class="co1">; más claro, 11 10 01 00</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rBGP<span class="br0">]</span>, <span class="kw3">a</span>               <span class="co1">; escribimos esto en el registro de paleta de fondo</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rOBP0<span class="br0">]</span>, <span class="kw3">a</span>              <span class="co1">; y en la paleta 0 de sprites</span>
&nbsp;
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="nu0">0</span>                    <span class="co1">; escribimos 0 en los registros de scroll X e Y</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rSCX<span class="br0">]</span>, <span class="kw3">a</span>               <span class="co1">; con lo que posicionamos la pantalla visible</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rSCY<span class="br0">]</span>, <span class="kw3">a</span>               <span class="co1">; al inicio (arriba a la izq) del fondo.</span>
&nbsp;
        <span class="kw1">call</span>    inicia_sonido           <span class="co1">; iniciamos el sistema de sonido</span>
&nbsp;
        <span class="kw1">call</span>    apaga_LCD               <span class="co1">; llamamos a la rutina que apaga el LCD</span>
&nbsp;
        <span class="co1">; cargamos los tiles en la memoria de tiles</span>
&nbsp;
        <span class="kw1">ld</span>              <span class="kw3">hl</span>, Tiles               <span class="co1">; cargamos en HL la dirección de nuestro tile</span>
        <span class="kw1">ld</span>              <span class="kw3">de</span>, _VRAM               <span class="co1">; en DE dirección de la memoria de video</span>
        <span class="kw1">ld</span>              <span class="kw3">b</span>, <span class="nu0">32</span>                   <span class="co1">; b = 32, numero de bytes a copiar (2 tiles)</span>
&nbsp;
.bucle_carga:
        <span class="kw1">ld</span>              <span class="kw3">a</span>,<span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>                  <span class="co1">; cargamos en A el dato apuntado por HL</span>
        <span class="kw1">ld</span>              <span class="br0">[</span><span class="kw3">de</span><span class="br0">]</span>, <span class="kw3">a</span>                 <span class="co1">; y lo metemos en la dirección apuntada en DE</span>
        <span class="kw1">dec</span>             <span class="kw3">b</span>                               <span class="co1">; decrementamos b, b=b-1</span>
        <span class="kw1">jr</span>              <span class="kw5">z</span>, .fin_bucle_carga <span class="co1">; si b = 0, terminamos, no queda nada por copiar</span>
        <span class="kw1">inc</span>             <span class="kw3">hl</span>                              <span class="co1">; incrementamos la dirección a leer de</span>
        <span class="kw1">inc</span>             <span class="kw3">de</span>                              <span class="co1">; incrementamos la dirección a escribir en</span>
        <span class="kw1">jr</span>              .bucle_carga    <span class="co1">; seguimos</span>
.fin_bucle_carga:
&nbsp;
        <span class="co1">; ahora limpiamos la pantalla (llenamos todo el mapa de fondo), con el tile 0</span>
&nbsp;
        <span class="kw1">ld</span>              <span class="kw3">hl</span>, _SCRN0
        <span class="kw1">ld</span>              <span class="kw3">de</span>, <span class="nu0">32</span>*<span class="nu0">32</span>               <span class="co1">; numero de tiles en el mapa de fondo</span>
.bucle_limpieza:
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="nu0">0</span>                    <span class="co1">; el tile 0 es nuestro tile vacio</span>
        <span class="kw1">ld</span>              <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>
        <span class="kw1">dec</span>             <span class="kw3">de</span>
        <span class="co1">; ahora tengo que comprobar si de es cero, para ver si tengo que</span>
        <span class="co1">; terminar de copiar. dec de no modifica ningñun flag, asi que no puedo</span>
        <span class="co1">; comprobar el flag zero directamente, pero para que de sea cero, d y e</span>
        <span class="co1">; tienen que ser cero los dos, asi que puedo hacer un or entre ellos,</span>
        <span class="co1">; y si el resultado es cero, ambos son cero.</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="kw3">d</span>                    <span class="co1">; cargamos d en a</span>
        <span class="kw1">or</span>              <span class="kw3">e</span>                               <span class="co1">; y hacemos un or con e</span>
        <span class="kw1">jp</span>              <span class="kw5">z</span>, .fin_bucle_limpieza  <span class="co1">; si d OR e es cero, de es cero. Terminamos.</span>
        <span class="kw1">inc</span>             <span class="kw3">hl</span>                              <span class="co1">; incrementamos la dirección a escribir en</span>
        <span class="kw1">jp</span>              .bucle_limpieza
.fin_bucle_limpieza
&nbsp;
        <span class="co1">; bien, tenemos todo el mapa de tiles lleno con el tile 0,</span>
        <span class="co1">; ahora vamos a crear el sprite.</span>
&nbsp;
        <span class="kw1">ld</span>              <span class="kw3">a</span>, 30
        <span class="kw1">ld</span>              <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; posición Y del sprite</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, 30
        <span class="kw1">ld</span>              <span class="br0">[</span>_SPR0_X<span class="br0">]</span>, <span class="kw3">a</span>    <span class="co1">; posición X del sprite</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, 1
        <span class="kw1">ld</span>              <span class="br0">[</span>_SPR0_NUM<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; número de tile en la tabla de tiles que usaremos</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, 0
        <span class="kw1">ld</span>              <span class="br0">[</span>_SPR0_ATT<span class="br0">]</span>, <span class="kw3">a</span>  <span class="co1">; atributos especiales, de momento nada.</span>
&nbsp;
        <span class="co1">; configuramos y activamos el display</span>
        <span class="kw1">ld</span>      <span class="kw3">a</span>, LCDCF_ON|LCDCF_BG8000|LCDCF_BG9800|LCDCF_BGON|LCDCF_OBJ8|LCDCF_OBJON
        <span class="kw1">ld</span>      <span class="br0">[</span>rLCDC<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
        <span class="co1">; preparamos las variables de la animacion</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, 1
        <span class="kw1">ld</span>              <span class="br0">[</span>_MOVX<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>_MOVY<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
        <span class="co1">;preparamos las variables para el sonido</span>
        <span class="co1">; nota actual</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, 0
        <span class="kw1">ld</span>              <span class="br0">[</span>_NOTA<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="co1">; contador retardo musical</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>_CONT_MUS<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
        <span class="co1">; bucle infinito</span>
animacion:
        <span class="co1">; lo primero, esperamos por el VBlank, ya que no podemos modificar</span>
        <span class="co1">; la VRAM fuera de él, o pasarán cosas raras</span>
.<span class="kw1">wait</span>:
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
        <span class="kw1">cp</span>              145
        <span class="kw1">jr</span>              <span class="kw5">nz</span>, .<span class="kw1">wait</span>
        <span class="co1">; incrementamos las y</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="br0">[</span>_SPR0_Y<span class="br0">]</span>    <span class="co1">; cargamos la posición Y actual del sprite</span>
        <span class="kw1">ld</span>              <span class="kw3">hl</span>, _MOVY               <span class="co1">; en hl, la dirección del incremento Y</span>
        <span class="kw1">add</span>             <span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>                 <span class="co1">; sumamos</span>
        <span class="kw1">ld</span>              <span class="kw3">hl</span>, _SPR0_Y
        <span class="kw1">ld</span>              <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>                 <span class="co1">; guardamos</span>
        <span class="co1">; comparamos para ver si hay que cambiar el sentido</span>
        <span class="kw1">cp</span>              <span class="nu0">152</span>                             <span class="co1">; para que no se salga de la pantalla (max Y)</span>
        <span class="kw1">jr</span>              <span class="kw5">z</span>, .dec_y
        <span class="kw1">cp</span>              16
        <span class="kw1">jr</span>              <span class="kw5">z</span>, .inc_y               <span class="co1">; lo mismo, minima coord (min Y = 16)</span>
        <span class="co1">; no hay que cambiar</span>
        <span class="kw1">jr</span>              .end_y
.dec_y:
        <span class="kw1">ld</span>              <span class="kw3">a</span>, -<span class="nu0">1</span>                   <span class="co1">; ahora hay que decrementar las Y</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>_MOVY<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="kw1">jr</span>              .end_y
.inc_y:
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="nu0">1</span>                    <span class="co1">; ahora hay que incrementar las Y</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>_MOVY<span class="br0">]</span>, <span class="kw3">a</span>
.end_y:
        <span class="co1">; vamos con las X, lo mismo pero cambiando los márgenes</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="br0">[</span>_SPR0_X<span class="br0">]</span>    <span class="co1">; cargamos la posición X actual del sprite</span>
        <span class="kw1">ld</span>              <span class="kw3">hl</span>, _MOVX               <span class="co1">; en hl, la dirección del incremento X</span>
        <span class="kw1">add</span>             <span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>                 <span class="co1">; sumamos</span>
        <span class="kw1">ld</span>              <span class="kw3">hl</span>, _SPR0_X
        <span class="kw1">ld</span>              <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>, <span class="kw3">a</span>                 <span class="co1">; guardamos</span>
        <span class="co1">; comparamos para ver si hay que cambiar el sentido</span>
        <span class="kw1">cp</span>              <span class="nu0">160</span>                             <span class="co1">; para que no se salga de la pantalla (max X)</span>
        <span class="kw1">jr</span>              <span class="kw5">z</span>, .dec_x
        <span class="kw1">cp</span>              <span class="nu0">8</span>                               <span class="co1">; lo mismo, minima coord izq = 8</span>
        <span class="kw1">jr</span>              <span class="kw5">z</span>, .inc_x
        <span class="co1">; no hay que cambiar</span>
        <span class="kw1">jr</span>              .end_x
.dec_x:
        <span class="kw1">ld</span>              <span class="kw3">a</span>, -<span class="nu0">1</span>                   <span class="co1">; ahora hay que decrementar las X</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>_MOVX<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="kw1">jr</span>              .end_x
.inc_x:
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="nu0">1</span>                    <span class="co1">; ahora hay que incrementar las X</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>_MOVX<span class="br0">]</span>, <span class="kw3">a</span>
.end_x:
        <span class="co1">; un pequeño retardo</span>
        <span class="kw1">call</span> retardo
        <span class="co1">; tocamos la nota siguiente</span>
        <span class="kw1">call</span> cambia_nota
        <span class="co1">; volvemos a empezar</span>
        <span class="kw1">jr</span>              animacion
&nbsp;
<span class="co1">; Rutina de apagado del LCD</span>
apaga_LCD:
        <span class="kw1">ld</span>              <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>
        <span class="kw1">rlca</span>                    <span class="co1">; Pone el bit alto de LCDC en el flag de acarreo</span>
        <span class="kw1">ret</span>             <span class="kw5">nc</span>              <span class="co1">; La pantalla ya está apagada, volver.</span>
&nbsp;
        <span class="co1">; esperamos al VBlank, ya que no podemos apagar la pantalla</span>
        <span class="co1">; en otro momento</span>
&nbsp;
.espera_VBlank
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="br0">[</span>rLY<span class="br0">]</span>
        <span class="kw1">cp</span>              145
        <span class="kw1">jr</span>              <span class="kw5">nz</span>, .espera_VBlank
&nbsp;
        <span class="co1">; estamos en VBlank, apagamos el LCD</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>,<span class="br0">[</span>rLCDC<span class="br0">]</span>               <span class="co1">; en A, el contenido del LCDC</span>
        <span class="kw1">res</span>             7,<span class="kw3">a</span>                             <span class="co1">; ponemos a cero el bit 7 (activado del LCD)</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rLCDC<span class="br0">]</span>,<span class="kw3">a</span>               <span class="co1">; escribimos en el registro LCDC el contenido de A</span>
&nbsp;
        <span class="kw1">ret</span>                                             <span class="co1">; volvemos</span>
&nbsp;
<span class="co1">; rutina de retardo</span>
retardo:
        <span class="kw1">ld</span>              <span class="kw3">de</span>, <span class="nu0">2000</span>                <span class="co1">; numero de veces a ejecutar el bucle</span>
.delay:
        <span class="kw1">dec</span>             <span class="kw3">de</span>                              <span class="co1">; decrementamos</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="kw3">d</span>                    <span class="co1">; vemos si es cero</span>
        <span class="kw1">or</span>              <span class="kw3">e</span>
        <span class="kw1">jr</span>              <span class="kw5">z</span>, .fin_delay
        <span class="kw1">nop</span>
        <span class="kw1">jr</span>              .delay
.fin_delay:
        <span class="kw1">ret</span>
&nbsp;
<span class="co1">; rutina para iniciar el sistema de sonido</span>
inicia_sonido:
        <span class="co1">; activamos sistema de sonido</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, %10000000
        <span class="kw1">ld</span>              <span class="br0">[</span>rNR52<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="co1">; iniciamos los volumenes, etc</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, %01110111            <span class="co1">; SO1 y S02 a tope de volumen</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rNR50<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
        <span class="kw1">ld</span>              <span class="kw3">a</span>, %00000010            <span class="co1">; Canal 2, sale por SO1 y S02</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rNR51<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
        <span class="co1">; canal 2, longitud 63, ciclo 50%</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, %10111111
        <span class="kw1">ld</span>              <span class="br0">[</span>rNR21<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="co1">; canal 2, envolvente, volumen inicial maximo, decreciente</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, %11110111
        <span class="kw1">ld</span>              <span class="br0">[</span>rNR22<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
        <span class="co1">; canal 2, longitud activada y valor de la frecuencia alta</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, %01000110            <span class="co1">; 1 en el bit 6, longitud activa, y</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rNR24<span class="br0">]</span>, <span class="kw3">a</span>              <span class="co1">; escribimos %110 en los tres bits altos de la frecuencia.</span>
&nbsp;
        <span class="kw1">ret</span>
&nbsp;
cambia_nota:
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="br0">[</span>_CONT_MUS<span class="br0">]</span>          <span class="co1">; vemos si hay que tocar la nota o esperar</span>
        <span class="kw1">cp</span>              <span class="kw3">a</span>, _TEMPO
        <span class="kw1">jr</span>              <span class="kw5">z</span>, .toca_nota
        <span class="kw1">inc</span>             <span class="kw3">a</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>_CONT_MUS<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="kw1">ret</span>
.toca_nota:
        <span class="co1">; reiniciamos el contador</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, 0
        <span class="kw1">ld</span>              <span class="br0">[</span>_CONT_MUS<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
        <span class="co1">; pasamos a tocar la nota</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="br0">[</span>_NOTA<span class="br0">]</span>              <span class="co1">; obtenemos el numero de nota a tocar</span>
        <span class="kw1">ld</span>              <span class="kw3">c</span>, <span class="kw3">a</span>                    <span class="co1">; lo guardamos</span>
        <span class="kw1">ld</span>              <span class="kw3">b</span>, 0
        <span class="kw1">ld</span>              <span class="kw3">hl</span>, Notas               <span class="co1">; en hl la dirección de las notas</span>
        <span class="kw1">add</span>             <span class="kw3">hl</span>, <span class="kw3">bc</span>                  <span class="co1">; ahora tenemos la dirección de la nota a tocar</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="br0">[</span><span class="kw3">hl</span><span class="br0">]</span>                 <span class="co1">; cargamos la Nota</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rNR23<span class="br0">]</span>, <span class="kw3">a</span>              <span class="co1">; la escribimos en el registro de frecuencia del canal 2</span>
        <span class="co1">; reiniciamos la nota</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="br0">[</span>rNR24<span class="br0">]</span>
        set             7,<span class="kw3">a</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>rNR24<span class="br0">]</span>, <span class="kw3">a</span>
&nbsp;
        <span class="co1">; pasamos a la siguiente nota y comprobamos si tenemos que reiniciar</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, <span class="kw3">c</span>
        <span class="kw1">inc</span>             <span class="kw3">a</span>
        <span class="kw1">cp</span>              <span class="kw3">a</span>, EndNotas - Notas     <span class="co1">; hemos llegado al final?</span>
        <span class="kw1">jr</span>              <span class="kw5">z</span>, .resetea_notas
        <span class="co1">; no, guardamos y volvemos</span>
        <span class="kw1">ld</span>              <span class="br0">[</span>_NOTA<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="kw1">ret</span>
.resetea_notas:
        <span class="co1">;si, reiniciarmos, guardamos y volvemos</span>
        <span class="kw1">ld</span>              <span class="kw3">a</span>, 0
        <span class="kw1">ld</span>              <span class="br0">[</span>_NOTA<span class="br0">]</span>, <span class="kw3">a</span>
        <span class="kw1">ret</span>
&nbsp;
<span class="co1">; Datos de nuestros tiles</span>
Tiles:
        <span class="kw4">DB</span>      $AA, $00, $44, $00, $AA, $00, $11, $00
        <span class="kw4">DB</span>      $AA, $00, $44, $00, $AA, $00, $11, $00
        <span class="kw4">DB</span>      $3E, $3E, $41, $7F, $41, $6B, $41, $7F
        <span class="kw4">DB</span>      $<span class="nu0">41</span>, $<span class="nu0">63</span>, $<span class="nu0">41</span>, $7F, $3E, $3E, $00, $00
EndTiles:
&nbsp;
<span class="co1">; Datos de la musica</span>
<span class="co1">; Vamos a usar la quinta octava, porque sus valores comparten los mismos</span>
<span class="co1">; tres bits superiores, %110, asi no tendremos que variarlos.</span>
Notas:
        <span class="co1">; 5ª Octava, Do, Re, Mi, Fa, Sol, La, Si (poniendo $6 en freq hi)</span>
        <span class="kw4">DB</span>      $0A, $<span class="nu0">42</span>, $<span class="nu0">72</span>, $<span class="nu0">89</span>, $B2, $D6, $F7
EndNotas:</pre>
</dd></dl>

<p>
And here the ROM if you want to hear:
<a href="http://wiki.ladecadence.net/lib/exe/fetch.php?media=hola-sonido1.gb" class="media mediafile mf_gb" title="hola-sonido1.gb">hola-sonido1.gb</a>

</p>

</div>

    <!-- wikipage stop -->
  </div>

  <div class="clearer">&nbsp;</div>

  
  <div class="stylefoot">

    <div class="meta">
      <div class="user">
              </div>
      <div class="doc">
        tutorial_de_ensamblador.txt · Última modificación: 2012/11/04 10:32 por zako      </div>
    </div>

   
    <div class="bar" id="bar__bottom">
      <div class="bar-left" id="bar__bottomleft">
        <form class="button btn_source" method="post" action="/doku.php"><div class="no"><input name="do" value="edit" type="hidden"><input name="rev" value="" type="hidden"><input name="id" value="tutorial_de_ensamblador" type="hidden"><input value="Ver fuente" class="button" accesskey="v" title="Ver fuente [V]" type="submit"></div></form>        <form class="button btn_revs" method="get" action="/doku.php"><div class="no"><input name="do" value="revisions" type="hidden"><input name="id" value="tutorial_de_ensamblador" type="hidden"><input value="Revisiones antiguas" class="button" accesskey="o" title="Revisiones antiguas [O]" type="submit"></div></form>              </div>
      <div class="bar-right" id="bar__bottomright">
                                        <form class="button btn_login" method="get" action="/doku.php"><div class="no"><input name="do" value="login" type="hidden"><input name="sectok" value="2d1e9263004673c1558c6b504e1e1abd" type="hidden"><input name="id" value="tutorial_de_ensamblador" type="hidden"><input value="Conectarse" class="button" title="Conectarse" type="submit"></div></form>        <form class="button btn_index" method="get" action="/doku.php"><div class="no"><input name="do" value="index" type="hidden"><input name="id" value="tutorial_de_ensamblador" type="hidden"><input value="Índice" class="button" accesskey="x" title="Índice [X]" type="submit"></div></form>        <a class="nolink" href="#dokuwiki__top"><input class="button" value="Ir hasta arriba" onclick="window.scrollTo(0, 0)" title="Ir hasta arriba" type="button"></a>&nbsp;
      </div>
      <div class="clearer"></div>
    </div>

  </div>

  <div class="license">Excepto donde se indique lo contrario, el contenido de esta wiki se autoriza bajo la siguiente licencia:<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="license" class="urlextern">CC Attribution-Noncommercial-Share Alike 3.0 Unported</a></div>
</div>

<div class="footerinc">

  <a href="http://wiki.ladecadence.net/feed.php" title="Recent changes RSS feed"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/button-rss.png" alt="Recent changes RSS feed" height="15" width="80"></a>

        <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" rel="license" title="CC Attribution-Noncommercial-Share Alike 3.0 Unported"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/cc-by-nc-sa.png" alt="" height="15" width="80"></a>
  
  <a href="http://www.dokuwiki.org/donate" title="Donate"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/button-donate.gif" alt="Donate" height="15" width="80"></a>

  <a href="http://www.php.net/" title="Powered by PHP"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/button-php.gif" alt="Powered by PHP" height="15" width="80"></a>

  <a href="http://validator.w3.org/check/referer" title="Valid XHTML 1.0"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/button-xhtml.png" alt="Valid XHTML 1.0" height="15" width="80"></a>

  <a href="http://jigsaw.w3.org/css-validator/check/referer?profile=css3" title="Valid CSS"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/button-css.png" alt="Valid CSS" height="15" width="80"></a>

  <a href="http://dokuwiki.org/" title="Driven by DokuWiki"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/button-dw.png" alt="Driven by DokuWiki" height="15" width="80"></a>



</div>

<div class="no"><img src="tutorial_de_ensamblador%20%5BLa%20decadence%5D_files/indexer.gif" alt="" height="1" width="1"></div>


</body></html>
